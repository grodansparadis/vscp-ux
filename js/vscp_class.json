{
    "CLASS1.PROTOCOL": {
        "vscpclass": 0,
        "vscpclass512": "CLASS2.CLASS1_PROTOCOL",
        "description": "VSCP Protocol Functionality",
        "vscptype": {
            "PROTOCOL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
            "SEGCTRL_HEARTBEAT": {
                "type": 1,
                "name": "Segment Controller Heartbeat",
                "description": "<p><strong>Not mandatory.</strong>Implement in device if needed by application.</p>
                <p>
                    A segment controller sends this event once a second on the segment that it controls.The data field 
                    contains the 8 - bit CRC of the segment controller GUID and the time since the 
                    epoch(00: 00: 00 UTC, January 1, 1970) as a 32 - bit value.A node that receive(and recognize) this event 
                    could respond with a CLASS1.INFORMATION, Type = 9 event(HEARTBEAT) and should do so if it does not send 
                    out a regular heartbeat event. 
                </p>
                <p>
                    Other nodes can originate this event on the segment.For these nodes the data part, as specified below, 
                    should be omitted.A better choice for periodic heartbeat events from a node may be CLASS1.INFORMATION, 
                    Type = 9(HEARTBEAT) 
                </p>
                <p>
                    All nodes that recognize this event should save the 8 - bit CRC in non - volatile storage and use it 
                    on power up.When a node starts up on a segment it should begin to listen for the Segment controller 
                    heartbeat.When/if it is received the node compares it with the stored value and if equal and the node 
                    is assigned a nickname - ID it continues to its working mode.If different, the node has detected that 
                    it has been moved to a new segment and therefore must drop its nickname - ID and enters the configuration 
                    mode to obtain a new nickname - ID from the segment controller. 
                </p>
                <p>
                    If the node is in working mode and its nickname - ID changes, the node should do a complete restart after 
                    first setting all controls to their default state. 
                </p>
                <p>
                    As a segment can be without a segment controller this event is not available on all segments and is not 
                    mandatory. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>8-bit CRC of the segment controller GUID.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>MSB of time since epoch (optional).</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Time since epoch (optional).</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Time since epoch (optional).</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>LSB of time since epoch (optional).</td >
                    </tr> 
                </table>
                <p>
                    Uninitiated nodes have the CRC of the segment controller set to 0xFF. 
                </p>
                <p>
                    A node that is initialized on a segment and does not receive a Heartbeat can take the role of segment 
                    controller if it wishes to do so.Only one node one a segment are allowed to do this fully by setting 
                    its nickname = 0 and therefore a standard node should not have this feature built in .Any node can however 
                    behave like a segment controller but use a nickname other then zero. 
                </p>",
                    "data": [{
                        "ordinal": "0",
                        "description": "8-bit CRC of the segment controller GUID."
                    }, {
                        "ordinal": "1",
                        "description": "MSB of time since epoch (optional)."
                    }, {
                        "ordinal": "2",
                        "description": "Time since epoch (optional)."
                    }, {
                        "ordinal": "3",
                        "description": "Time since epoch (optional)."
                    }, {
                        "ordinal": "4",
                        "description": "LSB of time since epoch (optional)."
                    }]
            },
            "NEW_NODE_ONLINE": {
                "type": 2,
                "name": "New node on line / Probe",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                This is intended for nodes that have been initiated, is part of the segment and is powered up.All nodes 
                that have a nickname - ID that is not set to 0xFF should send this event before they go on line to do 
                their“ day to day” work. 
                </p>
                <p>
                Normally all nodes should save their assigned nickname - ID in non - volatile memory and use this 
                assigned ID when powered up.A segment controller can however keep track of nodes that it controls and 
                reassign the ID to a node that it did not get a new node on - line event from.This is the method a 
                segment controller uses to detect nodes that have been removed from the segment. 
                </p>
                <p>
                For the nickname discovery procedure this event is used as the probe.The difference between a probe and 
                a new node on line is that the later has the same originating nickname as value in byte 0. 
                </p>
                <p>
                If a node send this event with the unassigned ID 0xFF and byte 0 set to 0xFF it has given up the search
                for a free ID. 
                </p>
                <p>
                It is recommended that also level II nodes send this event when they come alive.In this
                case the 16 - byte data is the GUID of the node. 
                </p> 
                <table>
                    <thead >
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td> <strong>Target address</strong > .This is the probe nickname that the new node is using to 
                        test if this is a valid target node.If there is a node with this nickname address it should answer 
                        with probe ACK.A probe always has 0xff as it & #039;s own temporary nickname while a new node on 
                        line use a non 0xff nickname. </td>
	                </tr>
                </table>",
                "data":
                        [{
                        "ordinal": "0",
                        "description": "<strong>Target address.</strong> This is the probe nickname that the new node is using to test if this is a valid target node. If there is a node with this nickname address it should answer with probe ACK. A probe always has 0xff as it's own temporary nickname while a new node on line use a non 0xff nickname. "
                    }]
            },
            "PROBE_ACK": {
                "type": 3,
                "name": "Probe ACK",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p> 
                <p>
                This event is sent from a node as a response to a probe.There are no arguments.
                </p>
                "
            },
            "reserved": {
                "type": 4,
                "name": "<p>Reserved for future use</p>",
                "description": ""

            },
            "reserved": {
                "type": 5,
                "name": "<p>Reserved for future use</p>",
                "description": ""
            },
            "SET_NICKNAME": {
                "type": 6,
                "name": "Set nickname-ID for node",
                "desciption": "<p> <strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    This event can be used to change the nickname
                    for a node.The node just uses the new nickname and don & #039;t start nickname discovery or similar.
                </p>
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Old nickname for node.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>The new nickname for the node.</td >
                    </tr> 
                </table>",
                "date": [{
                    "ordinal": "0",
                    "description": "Old nickname for node."
                }, {
                    "ordinal": "1",
                    "description": "The new nickname for the node."
                }]
            },
            "NICKNAME_ACCEPTED": {
                "type": 7,
                "name": "Nickname-ID accepted",
                "desciption": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p> 
                <p>
                    A node sends this event to confirm that it accepts its assigned nickname - ID.When sending this event the 
                    node uses its newly assigned nickname address. 
                </p>"
            },
            "DROP_NICKNAME": {
                "type": 8,
                "name": "Drop nickname-ID / Reset Device",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Request a node to drop its nickname.The node should drop its nickname and then behave in the same manner 
                    as when it was first powered up on the segment. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th> Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>The current nickname for the node.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td><strong>Optional:</strong >Flags.</td> 
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td><strong>Optional:</strong>Time the node should wait before it starts a nickname discovery or starts 
                            the device.The time is in seconds.</td> 
                    </tr> 
                </table>
                <p>
                    <strong >Optional byte 1 flags </strong> 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Bit</th>
                            <th> Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Reserved.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Reserved.</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Reserved.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Reserved.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Reserved.</td>
                    </tr> 
                    <tr>
                        <td >5</td>
                        <td>Reset device. Keep nickname.</td >
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>Set persistent storage to default.</td>
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>Go idle. Do not start up again.</td>
                    </tr> 
                </table>
                <p>
                    So if byte 1 and 2 is not in event restart device, set default parameters and do a nickname discovery.If 
                    byte 1 and 2 are present and bit 5 is set load defaults into device, restart but keep nickname.In all cases 
                    byte 2 delays before the node is restarted. 
                </p> 
                <ol>
                    <li>
                        <div>With just one byte as an argument.The node should do a standard node discovery in the same way as
                        if the status button of the node is pressed.Preserve initiated data,</div> 
                    </li> 
                    <li> 
                        <div>If byte 1 is present bit 5: Just restart.Don & #039;t change any data. not even nickname. bit 6: 
                        Restart write default to persistent storage. bit 7: die die my darling. If both bit 5 and 6 is set, 
                        do 5 and then 6 = = 6 or do 6 and then 5 == 6 </div> 
                    </li> 
                    <li> 
                        <div>Byte 1 + byte 2 Wait this amount of seconds after the above operation has been carried out.</div> 
                    </li> 
                </ol>
                <p>
                    There is a variant of this where the GUID is used instead of the nickname to identify the device, 
                    Class = 0, Type = 23. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "READ_REGISTER": {
                "type": 9,
                "name": "Read register",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Read a register from a node. 
                </p>
                <p>
                    <em>If a node have several pages with user defined registers Extended Register Read is a better choice to 
                    choose for reading as the page also is set when reading register using that type.The standard registers 
                    can always be read without setting a page though as they are always mapped into the upper 128 bytes.</em> 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node address.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Register to read.</td >
                    </tr> 
                </table>
                <p>
                    A read / write response event is returned on success. 
                </p>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II handling 
                    as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID (MSB → LSB).</td >
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>Reserved.</td >
                    </tr> 
                    <tr>
                        <td>17</td>
                        <td>Register to read.</td >
                    </tr> 
                </table>",
                "data": [
                    { "ordinal": "0", "description": "" }, 
                ]
            },
            "RW_RESPONSE": {
                "type": 10,
                "name": "Read/Write response",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Response for a read / write event..Note that the data is returned for both a read and a write and can and 
                    probably should be checked for validity. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Register read/written.</td> 
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Content of register.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "WRITE_REGISTER": {
                "type": 11,
                "name": "Write register",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Write register content to a node. 
                </p>
                <p>
                    <em>If a node have several pages with user defined registers Extended Register Write is a better choice to 
                    choose for writing as the page is also set when writing a register using that type.The standard registers can 
                    always be read without setting a page though as they are always mapped into the upper 128 bytes. < /em> 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node address.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Register to write.</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Content for register.</td >
                    </tr> 
                </table>
                <p>
                    A read / write response event is returned on success. 
                </p>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID (MSB → LSB).</td >
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td> Reserved.</td >
                    </tr> 
                    <tr>
                        <td>17</td>
                        <td>Register to write.</td >
                    </tr> 
                    <tr>
                        <td>18</td>
                        <td>Content of register.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "ENTER_BOOT_LOADER": {
                "type": 12,
                "name": "Enter boot loader mode",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Send NACK(Class = 0, Type = 14
                    if no boot - loader implemented) 
                </p>
                <p>
                    This is the first event in the boot loader sequence.The node should stop all other activities when in 
                    boot loader mode.This also means that the node should not react on other events(commands) then the boot 
                    loader related. 
                </p> 
                <table>
                    <thead >
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>The nickname for the node.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Code that select boot loader algorithm to use.</td >
                    </tr> 
                    <tr>
                        <td>2< /td>
                        <td>GUID byte 0 (MSB)</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>GUID byte 3 (MSB + 3)</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>GUID byte 5 (MSB + 5)</td >
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>GUID byte 7 (MSB + 7)</td>
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>Content of register 0x92, Page select MSB.</td >
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>Content of register 0x93, Page select LSB.</td >
                    </tr> 
                </table>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15 </td>
                        <td>GUID.</td>
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>Boot-loader algorithm code.</td >
                    </tr> 
                </table>
                <p>
                <strong>Boot - loader Codes </strong> 
                </p>
                < table>
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th> Algorithm</th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0x00</td>
                        <td>VSCP algorithm.</td >
                    </tr> 
                    <tr>
                        <td>0x01</td>
                        <td>Microchip PIC algorithm</td >
                    </tr> 
                    <tr>
                        <td>0x10</td>
                        <td>Atmel AVR algorithm 0</td >
                    </tr> 
                    <tr>
                        <td>0x20</td>
                        <td>NXP ARM algorithm 0</td >
                    </tr> 
                    <tr>
                        <td>0x30</td>
                        <td>ST ARM algorithm 0</td >
                    </tr> 
                </table>
                <p>
                    All other reserved. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "ACK_BOOT_LOADER": {
                "type": 13,
                "name": "ACK boot loader mode",
                "description": "<p><strong>Not mandatory.< /strong>Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    This event has no meaning for any node that is not in boot mode and should be disregarded. 
                </p>
                <p>
                    The node confirms that it has entered boot loader mode.This is only sent for the VSCP boot loader algorithm. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>MSB of flash block size.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Flash block size.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Flash block size.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>LSB of flash block size.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>MSB of number of block s available.</td >
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>Number of block s available.</td >
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>Number of block s available.</td >
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>LSB of number of blocks available.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "NACK_BOOT_LOADER": {
                "type": 14,
                "name": "NACK boot loader mode",
                "description": "<p><strong>Mandatory.</strong>Should be implemented by all devices.</p>
                <p>
                    The node was unable to enter boot loader mode.The reason is given by a user specified error code byte.
                    This event has no meaning for any node that is not in boot mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Optional user defined error code.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "START_BLOCK": {
                "type": 15,
                "name": "Start block data transfer",
                "description": "<p><strong>Not mandatory.</strong>Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    Begin transfer of data for a block of memory.This event has no meaning for any node that is not in boot 
                    mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th >
                        </tr> 
                    </thead> <
                    tr>
                        <td>0</td>
                        <td>MSB of block number.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Block number.</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Block number.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>LSB of block number.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>(optional) Type of Memory we want to write. See table below </td >
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>(optional) Bank/Image to be written Used together with byte 4 to specify either separate Flash 
                        or EEPROM / MRAM spaces.If absent or set to zero normally, means first memory from the view of the 
                        node creator, e.g.internal Flash, internal EEPROM etc.Useful for projects that have internal as well 
                        as external EEPROMs so the external one could be addressed with byte5 = 1. Also with byte4 = 0 and 
                        byte5 = 1 an SD - Card as well as a second firmware image inside the flash could be addressed. 
                        </td>
                    </tr> 
                </table>
                <p>
                    <strong > Type of memory to write(byte 4) < /strong> 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Memory type</th>
                            <th>Description </th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0 or byte absent</td>
                        <td>PROGRAM Flash (status quo for old nodes)</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>DATA (EEPROM, MRAM, FRAM)</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>CONFIG (Fuses, CPU configuration)</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>RAM</td >
                    </tr> 
                    <tr>
                        <td>4 - 255 </td>
                        <td>Currently undefined - send a NACK as response </td >
                    </tr> 
                </table>
                <p>
                    Response can be Class = 0, Type = 50(Start block data transfer ACK) or Class = 0, Type = 51(Start block 
                    data transfer NACK). 
                <
                /p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "BLOCK_DATA": {
                "type": 16,
                "name": "Block data",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    Data for a block of memory.This event has no meaning for any node that is not in boot mode and should be 
                    disregarded. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description </th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Data.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>Data.</td >
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>Data.</td >
                    </tr> 
                </table>
                <p>
                    A <stong>Block Data ACK</strong> (or a <strong>Block data NACK</strong> on failure) is sent as a response 
                    for each event received.
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "BLOCK_DATA_ACK": {
                "type": 17,
                "name": "ACK data block",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    Confirm the reception of a complete data block.This event has no meaning
                    for any node that is not in boot mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>MSB of 16-bit CRC for block.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>LSB for 16-bit CRC for block.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>MSB of write pointer.</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>write pointer.</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                    <td>write pointer.</td>
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>LSB of write pointer.</td >
                    </tr> 
                </table>
                <p>
                    The write pointer is the actual pointer after the last data has been written i, e the next position on which data 
                    will be written. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "BLOCK_DATA_NACK": {
                "type": 18,
                "name": "NACK data block",
                "description": "<p><strong>Not mandatory.</strong>Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    NACK the reception of data block.This event has no meaning
                    for any node that is not in boot mode and should be disregarded. 
                </p> 
                < table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description </th >
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>User defined error code.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>MSB of write pointer.</td>
                    </tr> 
                    <tr>
                        <td>2< /td>
                        <td>write pointer. </td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>write pointer.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>LSB of write pointer.</td >
                    </tr> 
                </table>
                <p>
                    The write pointer is the actual pointer after the last data has been written i, e the next position on 
                    which data will be written. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "PROGRAM_BLOCK_DATA": {
                "type": 19,
                "name": "Program data block",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    Request from a node to program a data block that has been uploaded and confirmed.This event has no meaning
                    for any node that is not in boot mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th> Description</th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>MSB of block number.</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Block number.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Block number.</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>LSB of block number.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "PROGRAM_BLOCK_DATA_ACK": {
                "type": 20,
                "name": "ACK program data block",
                "description": "<p><strong>Not mandatory.</strong>Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    A node confirms the successful programming of a block.This event has no meaning
                    for any node that is not in boot mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description </th>
                        </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>MSB of block number.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Block number.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Block number.</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>LSB of block number.</td>
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "PROGRAM_BLOCK_DATA_NACK": {
                "type": 21,
                "name": "NACK program data block",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    A node failed to program a data block.This event has no meaning
                    for any node that is not in boot mode and should be disregarded. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>User defined error code.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>MSB of block number.</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Block number.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Block number.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>LSB of block number.</td>
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "ACTIVATE_NEW_IMAGE": {
                "type": 22,
                "name": "Activate new image",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    This command is sent as the last command during the boot - loader sequence.It resets the device and 
                    starts it up using the newly loaded code.The 16 - bit CRC for the entire program block is sent as an 
                    argument.This must be correct for the reset / activation to be performed.NACK boot loader mode will be 
                    sent if the CRC is not correct and the node will not leave boot loader mode. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th><th>Description</th>
                        </tr> 
                    </thead>
                    <tr>
                        <td>0</td>
                        <td>16 bit CRC of full flash data block, MSB </td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>16 bit CRC of full flash data block LSB </td>
                    </tr> 
                </table>
                <p>
                    To leave boot mode just send this event and a dummy CRC.Other methods could have been used to load the 
                    code but it can still be activated with this event as long as the CRC is correct.This event has no meaning
                    for any node that is not in boot mode and should be disregarded.Response can be Class = 0, type = 48 
                    (Activate new image ACK) or Class = 0, Type = 49(Activate new image NACK). 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "RESET_DEVICE": {
                "type": 23,
                "name": "GUID drop nickname-ID / reset device",
                "description": "<p><strong>Mandatory.</strong> Should be implemented by all devices.</p>
                <p>Added in version 1.4 .0 </p>
                <p>
                    This is a variant of Class = 0, Type = 8 but here the full GUID is used instead of the 
                    nickname to identify the node that should drop its current nickname and enter the node - 
                    name discovery procedure. 
                </p>
                <p>
                    As the GUID is 16 bytes this is a multi - frame event.To ease the storage requirements on the nodes 
                    only four GUID bytes are send in each frame.The frames must be sent out within one second interval. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>index.</td >
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>GUID byte.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>GUID byte.</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>GUID byte.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td> GUID byte</td>
                    </tr> 
                </table>
                <p>
                    where index goes from 0 - 3 and GUID bytes are sent MSB first, like 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Index = Byte 0</th>
                            <th>Byte 1</th> 
                            <th>Byte 2</th>
                            <th>Byte 3</th> 
                            <th>Byte 4</th> 
                        </tr> 
                    </thead> 
                    <tr>
                        <td>Index = 0</td>
                        <td>GUID byte 15</td> 
                        <td>GUID byte 14</td>
                        <td>GUID byte 13</td> 
                        <td>GUID byte 12</td> 
                    </tr> 
                    <tr>
                        <td>Index = 1</td>
                        <td>GUID byte 11</td >
                        <td>GUID byte 10</td>
                        <td>GUID byte 9</td>
                        <td>GUID byte 8</td> 
                    </tr> 
                    <tr>
                        <td>Index = 2</td>
                        <td>GUID byte 7</td> 
                        <td>GUID byte 6</td>
                        <td>GUID byte 5</td> 
                        <td>GUID byte 4</td> 
                    </tr> 
                    <tr>
                        <td>Index = 3</td>
                        <td>GUID byte 3</td > 
                        <td>GUID byte 2</td>
                        <td>GUID byte 1</td>
                        <td>GUID byte 0</td> 
                    </tr> 
                </table>
                <p>
                    A device can use just one byte to detect this.This byte is initialized to zero and holds four bits that 
                    match correct frames.That is, when this register is equal to 0x0f the nickname should be dropped and the 
                    nickname discovery sequence started.The node must also have a timer that reset this byte one second after 
                    any of the above frames have been received or when the nickname discovery sequence is started. 
                </p>
                <p>
                    Hi - level software must take this one second interval into account when more then one node should be 
                    initialized.This event can be used to assign nickname - IDs to silent nodes.This is nodes that does not 
                    start the nickname discovery process on startup and instead just sits and wait until they are assigned an 
                    ID with this event. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "PAGE_READ": {
                "type": 24,
                "name": "Page read",
                "description": "<p> <strong >Mandatory.</strong> Should be implemented by all devices.</p>
                <p>
                    The page read is implemented to make it possible to read / write larger blocks of data.
                    Two register positions are reserved to select a base into this storage.This is a 16 - bit number 
                    pointing to a 256 - byte page.This means that a total of 65535 * 256 bytes are accessible with this 
                    method(page 0 is the standard registers). 
                </p>
                <p>
                    To read a block of data from the storage, first write the base registers then issue this event and n 
                    events will be sent out from the node containing the data from the specified area.If the count pass the 
                    border it of the page( & gt; 0xFF) the transfer will end there. 
                </p>
                <p>
                    Note that the page select registers only selects a virtual page that can be accessed with page read / write 
                    and not with the ordinary read / write. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node-ID which registers should be read.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Index into page.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Number of bytes to read (1-255).</td>
                    </tr> 
                </table>
                <p>
                    Response is 
                </p> 
                <pre class = "code" > Class = 0, Type = 26(0x1A) Read page response. < /pre>
                <p>
                    The following format can be used
                    for nodes on a Level II segment as a midway between a full Level II handling as specified in Class = 1024 
                    and Level I. 
                </p> 
                <table>
                    <thead>
                        <tr>
                            <th>Data byte</th>
                            <th>Description</th>
                        </tr> 
                    </thead>
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID.</td>
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>Index into page.</td>
                    </tr> 
                    <tr>
                        <td>17</td>
                        <td>Number of bytes to read (1-255).</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "PAGE_WRITE": {
                "type": 25,
                "name": "Page write",
                "description": "<p><strong>Mandatory.</strong> Should be implemented by all devices.</p>
                <p>
                    The write page is implemented to make it possible to write larger blocks of data.One 
                    data - space positions is reserved to select a base into this storage.See Page read
                    for a full description. 
                </p>
                <p>
                    It is only possible to write one 6 - byte chunk at a time in contrast to reading several.
                    This is because VSCP at Level I is aimed at low end devices with limited resources meaning 
                    little room for buffers. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node-ID </td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Register start.</td>
                    </tr> 
                    <tr>
                        <td>2-7</td>
                        <td> Data.</td >
                    </tr> 
                </table>
                <p>
                    Response is 
                </p> 
                <pre class = "code" >Class = 0, Type = 26(0x1A) Read Page Response. < /pre>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15 </td>
                        <td>GUID.</td>
                    </tr> 
                    <tr>
                        <td> 16 < /td>
                        <td> Base index. </td>
                    </tr> 
                    <tr>
                        <td> 18 - … </td>
                        <td> Data. </td >
                    </tr> 
                </table>
                <p>
                    Data count can be as many as the buffer of the Level II node accepts. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "RW_PAGE_RESPONSE": {
                "type": 26,
                "name": "Read/Write page response",
                "description": "<p><strong>Mandatory.</strong>Should be implemented by all devices.</p>
                <p>
                    This is a response frame for the read / write page command.The Sequence number goes from 0 up 
                    to the last sent frame for a read page request. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Sequence number.</td>
                    </tr> 
                    <tr>
                        <td>1 - 7</td>
                        <td>Data.</td >
                    </tr> 
                </table>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full 
                    Level II handling as specified in Class = 1024 and Level I. 
                </p> 
                < table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID.</td>
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>Sequence number.</td >
                    </tr> 
                    <tr>
                        <td>17 - … </td>
                        <td>Data.</td>
                    </tr> 
                </table>
                <p>
                    Data count can be as many as the buffer of the Level II node accepts. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "HIGH_END_SERVER_PROBE": {
                "type": 27,
                "name": "High end server probe",
                "description": "<p>Should be implemented by all devices that work over 802.15 .4 / Ethernet / Internet or other 
                    high end protocols. 
                </p>
                <p>
                    This event can be broad - casted on a segment by a node to get information about available servers. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Code for node type.</td>
                    </tr> 
                    <tr>
                        <td>1 - 7</td>
                        <td>Meaning depends on code in byte 0.</td>
                    </tr> 
                </table>
                <p>
                    <strong>Code node type byte < /strong> 
                </p>
                <p>
                    Code Description 0 this is a TCP / IP node, byte 1 - 4 is the V4 IP address of the node.Byte 5 -
                    if available - tells the capabilities of this node. 
                </p>
                <p>
                    <strong>Capabilities byte(byte 5)</strong> 
                </p>
                <p>
                    Code Description Bit 0 Node will log in to server using text mode.Bit 1 Node will log in to server 
                    using binary mode.Bit 2 Node expect server to connect using text mode.Bit 3 Node expect server to 
                    connect using binary mode.Bit 4 - 7 Reserved. 
                </p>
                <p>
                    Bit 0 + Bit 1 can be set at the same time indicating that the node can handle both modes.Bit 2 + 
                    bit 3 can be set at the same time indicating that the node can handle both modes. 
                </p>
                <p>
                    The VSCP daemon documentation have a description on how server discovery works[sub: Server - discovery] 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "HIGH_END_SERVER_RESPONSE": {
                "type": 28,
                "name": "High end server response",
                "description": "<p>Should be implemented by all devices that work on 802.15 .4 / Ethernet / Internet and have 
                    a Level I link.This is because a Level II device can be present on a Level I bus.A typical example is a 
                    Bluetooth gateway.A user find the bud / segment by the Bluetooth device and can then discover other parts 
                    of the system through it. 
                </p>
                <p>
                    For Level II devices the <strong>CLASS2.PROTOCOL, Type = 20(0x14) High end server capabilities </strong> 
                    is the solution to this problem. 
                </p> 
                <table>
                <thead>
                <tr>
                    <th>Data byte</th>
                    <th>Description</th>
                </tr> 
                </thead>
                <tr>
                    <td>0</td>
                    <td>VSCP server 16-bit capability code MSB</td >
                </tr> 
                <tr>
                    <td>1</td>
                    <td>Code for server capabilities LSB</td >
                </tr> 
                <tr>
                    <td>2</td>
                    <td>Server IP address MSB - or other relevant data as of server capabilities (Network byte order)</td>
                </tr> 
                <tr>
                    <td>3</td>
                 <td>Server IP address - or other relevant data as of server capabilities (Network byte order)</td>
                </tr> 
                <tr>
                    <td>4</td>
                    <td>Server IP address - or other relevant data as of server capabilities (Network byte order)</td>
                </tr> 
                <tr>
                    <td>5</td>
                    <td>Server IP address LSB - or other relevant data as of server capabilities (Network byte order) </td>
                </tr> 
                <tr>
                    <td>6</td>
                    <td> Server Port MSB - or other relevant data as of server capabilities </td>
                </tr> 
                <tr>
                    <td>7</td>
                    <td>Server Port LSB - or other relevant data as of server capabilities</td>
                </tr> 
            </table>
            <p>
                Bit codes for capabilities is the same as for the lower 16 bits of <strong>CLASS2.PROTOCOL, Type = 20(0x14) High 
                end server capabilities </strong>. 
            </p>
            <p>
                <strong>For programmers: < /strong> Bits are defined in <em>vscp.h</em > . 
            </p>
            <p>
                A node that need a TCP connection to a host.Broadcast HIGH END SERVER PROBE on the segment and waits
                for HIGH END SERVER RESPONSE from one or more servers to connect to.If a suitable server has responded 
                it can decide to connect to that server. 
            </p>
            <p>
                A daemon like the canal daemon can span multiple segments and a reply can therefore be received from a 
                remote segment as well.This can be an advantage in some cases and unwanted in some cases.The server configuration 
                should have control on how it is handled. 
            </p>
            <p>
                The VSCP daemon documentation have a description on how server discovery works. 
            </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "INCREMENT_REGISTER": {
                "type": 29,
                "name": "Increment register",
                "description": "<p><strong>Mandatory.</strong> Should be implemented by all devices.</p>
                <p>
                    Increment a register content by one with no risk of it changing in between 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead>
                    <tr>
                        <td>0</td>
                        <td>Node-ID</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Register to increment.</td>
                    </tr> 
                </table>
                <p>
                    Node should answer with Read / Write register response.Class = 0, Type = 10 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "DECREMENT_REGISTER": {
                "type": 30,
                "name": "Decrement register",
                "description": "<p><strong>Mandatory.</strong>Should be implemented by all devices.</p>
                <p>
                    Decrement a register content by one with no risk of it changing in between 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node-ID</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Register to decrement.</td>
                    </tr> 
                </table>
                <p>
                    Node should answer with Read / Write register response.Class = 0, Type = 10 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "WHO_IS_THERE": {
                "type": 31,
                "name": "Who is there?",
                "description": "<p><strong>Mandatory.</strong> Must be implemented by all devices.</p>
                <p>
                    This event can be used as a fast way to find out which nodes there is on a segment.All nodes receiving 
                    it should respond. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node-ID or 0xFF for all nodes.</td>
                    </tr> 
                </table>
                <p>
                    Response is 
                </p> 
                <pre class = "code" > Class = 0, Type = 32. < /pre>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "WHO_IS_THERE_RESPONSE": {
                "type": 32,
                "name": "Who is there response",
                "description": "<p><strong>Mandatory.</strong> Must be implemented by all devices.</p>
                <p>
                    Response from node(s) looks like this 
                </p> 
                 <table>
                    <thead>
                    <tr>
                        <th>byte 0</th>
                        <th>byte 1</th> 
                        <th>byte 2 </th>
                        <th>byte 3</th> 
                        <th>byte 4</th>
                        <th>byte 5</th> 
                        <th>byte 6</th>
                        <th>byte 7</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>GUID15</td> 
                        <td>GUID14</td>
                        <td>GUID13</td> 
                        <td>GUID12</td>
                        <td>GUID11</td> 
                        <td>GUID10</td>
                        <td>GUID9</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>GUID8</td> 
                        <td>GUID7</td>
                        <td>GUID6</td> 
                        <td>GUID5</td>
                        <td>GUID4</td> 
                        <td>GUID3</td>
                        <td>GUID2</td >
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>GUID1</td>
                        <td>GUID0</td>
                        <td>MDF0</td> 
                        <td>MDF1</td>
                        <td>MDF2</td> 
                        <td>MDF3</td>
                        <td>MDF4</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>MDF5</td> 
                        <td>MDF6</td>
                        <td>MDF7</td > 
                        <td>MD8</td>
                        <td>MDF9</td> 
                        <td>MDF10</td>
                        <td>MDF11</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>MDF12</td> 
                        <td>MDF13</td>
                        <td>MDF14</td> 
                        <td>MDF15</td>
                        <td>MDF16</td> 
                        <td>MDF17</td>
                        <td>MDF18</td>
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>MDF19</td> 
                        <td>MDF20</td>
                        <td>MDF21</td> 
                        <td>MDF22</td>
                        <td>MDF23</td > 
                        <td>MDF24</td>
                        <td>MDF25</td >
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>MDF26</td> 
                        <td>MDF27</td>
                        <td>MDF28</td> 
                        <td>MDF29</td>
                        <td>MDF30</td> 
                        <td>MDF31</td>
                        <td>0</td>
                    </tr> 
                </table>
                <p>
                    All seven frames should be sent also if the MDF URL is shorter then 32 characters, 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_MATRIX_INFO": {
                "type": 33,
                "name": "Get decision matrix info",
                "description": "<p> <strong>Mandatory</strong></p>
                <p>
                    Request a node to report size and offset for its decision matrix. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th >
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node address.</td >
                    </tr> 
                </table>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID.</td>
                    </tr> 
                </table>
                <p>
                    A node that does not have a decision matrix should return zero rows. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_MATRIX_INFO_RESPONSE": {
                "type": 34,
                "name": "Decision matrix info response",
                "description": "<p><strong>Mandatory</strong> for nodes with a decision matrix</p>
                <p>
                    Report the size for the decision matrix and the offset to its storage.The reported size is the number of 
                    decision matrix lines.The offset is the offset in the register address counter from 0x00(See the register 
                    model in this document).If the size returned is zero the node does not have a decision matrix.A node without 
                    a decision matrix can also skip to implement this event but it & #039;s better if it returns a decision 
                    matrix size of zero. 
                </p>
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Matrix size (number of rows). Zero for a device with no decision matrix.</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>Offset in register space.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Optional page start MSB ( Interpret as zero if not sent )</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Optional page start LSB ( Interpret as zero if not sent )</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Optional page end MSB ( Interpret as zero if not sent ) Deprecated. Set to zero.</td>
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>Optional page end LSB ( Interpret as zero if not sent ) Deprecated. Set to zero.</td>
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>For a Level II node this is the size of a decision matrix row.</td>
                    </tr> 
                </table>
                <p>
                    The decision matrix can as noted be stored in paged registers and if so it must be accessed with the 
                    paged read / write.The decision matrix can also be stored indexed.In that case the first byte is the 
                    index and the second is the data.If the index is in location 0x7f then an indexed matrix is assumed. 
                </p> 
                <table>
                <thead>
                <tr>
                    <th>Register position</th>
                    <th>Description</th>
                </tr> 
                </thead> 
                <tr>
                    <td>0x77</td>
                    <td>Index for row in decision matrix.</td>
                </tr> 
                <tr>
                    <td>0x78 - 0x7F</td>
                    <td>Level I decision matrix row.</td>
                </tr> 
            </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_EMBEDDED_MDF": {
                "type": 35,
                "name": "Get embedded MDF",
                "description": "<p><strong>Not mandatory.</strong></p>
                <p>
                    A node that get this event and has an embedded MDF description in flash or similar respond 
                    with the description. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th >
                    </tr> 
                    </thead>
                    <tr>
                        <td>0</td>
                        <td>Node-ID.</td >
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_EMBEDDED_MDF_RESPONSE": {
                "type": 36,
                "name": "Embedded MDF response",
                "description": "<p><strong>Not mandatory.</strong>See CLASS1.PROTOCOL, Type=35</p>
                <p>
                    This is the response from a Get embedded MDF.The response consist of several frames where an index in 
                    byte0 / 1 is incremented for each frame and MDF data is in byte 2 - 7. 
                </p>
                <p>
                    If an embedded MDF is not available a response on the form 
                </p> 
                    <pre class = "code" > 
                            byte 0 = 0
                            byte 1 = 0
                            byte 2 = 0 
                    </pre>
                <p>
                    should be sent. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead>
                    <tr>
                        <td>0</td>
                        <td> High byte of MDF description index.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Low byte of MDF description index.</td>
                    </tr> 
                    <tr>
                        <td>2 - 7</td>
                        <td>MDF data.</td>
                    </tr> 
                </table>
                <p>
                    Note that if sending the events back to back some devices will not be able to cope with the data stream.
                    It is therefor advisable to have a short delay between each mdf data frame sent out. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "EXTENDED_PAGE_READ_REGISTER": {
                "type": 37,
                "name": "Extended page read register",
                "description": "<p><strong>Mandatory.</strong>Must be implemented by all devices.</p>
                <p>
                    Read a register from a node with page information.
                </p>
                <p>
                    Implementation must take care so all page register change done by these routines must restore the content 
                    of the page registers to there original content when they are done. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr>
                    </thead>
                    <tr>
                        <td>0</td>
                        <td>Node address.</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>MSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>LSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Register to read (offset into page).</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Optional: Number of registers to read.</td>
                    </tr> 
                </table>
                <p>
                    If the number of registers to read is set to zero 256 registers will be read. < em> Some nodes my 
                    have small buffers so this bursts of messages may be a problem.</em> </p>
                <p>
                    An extended read / write response event is returned on success. 
                </p>
                <p>
                    This means that a register(or a maximum of 256 consecutive registers) located on any page can be 
                    read in a single operation. 
                </p>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p>
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID.</td>
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>MSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>17</td>
                        <td>LSB of page where the register is located.</td>
                    </tr>
                    <tr>
                        <td>18</td>
                        <td>Register to read.</td>
                    </tr> 
                    <tr>
                    <td>19</td>
                    <td>Optional: bytes to read (1-255).</td>
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "EXTENDED_PAGE_WRITE_REGISTER": {
                "type": 38,
                "name": "Extended page write register",
                "description": "<p><strong> Mandatory. </strong> Must be implemented by all devices.</p>
                <p>
                    Write register content to a node. 
                </p>
                <p>
                    Implementation must take care so all page register change done by these routines must restore the 
                    content of the page registers to there original content when they are done. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th >
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Node address.</td >
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td> MSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>LSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Register to write.</td >
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Content for register.</td>
                    </tr> 
                    <tr>
                        <td> 5, 6, 7 </td>
                        <td>Optional extra data bytes to write.</td>
                    </tr> 
                </table>
                <p>
                    A read / write response event is returned on success. 
                </p>
                <p>
                    Event allows a register(or a maximum of four consecutive registers) located on any page can be 
                    written in a single operation. 
                </p>
                <p>
                    The following format can be used for nodes on a Level II segment as a midway between a full Level II 
                    handling as specified in Class = 1024 and Level I. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0 - 15</td>
                        <td>GUID.</td >
                    </tr> 
                    <tr>
                        <td>16</td>
                        <td>MSB of page where the register is located.</td >
                    </tr> 
                    <tr>
                        <td>17</td>
                        <td> LSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>18</td>
                        <td>Register to write.</td >
                    </tr> 
                    <tr>
                        <td>19</td>
                        <td>Content of register. byte 20-buffer-size Optional extra data bytes to write.</td>
                    </tr> 
                </table>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "EXTENDED_PAGE_RW_RESPONSE": {
                "type": 39,
                "name": "Extended page read/write response",
                "description": "<p><strong>Mandatory.</strong> Must be implemented by all devices.</p>
                <p>
                    This is the replay sent for events CLASS1.PROTOCOL, Type = 40, 41. 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr>
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Index (starts at zero).</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>MSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>LSB of page where the register is located.</td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>Register read/written.</td> 
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>Content of register.</td>
                    </tr> 
                    <tr>
                        <td>5 - 7</td>
                        <td>Content of register if multi register read/write.</td> 
                    </tr> 
                </table>
                <p>
                    A multi.register read / write can generate up to 256 events of this type.Index will then be increased 
                    by one for each event sent. < em> Some nodes my have small buffers so this bursts of messages may be a 
                    problem.Therefore send them with a low priority. < /em> 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_EVENT_INTEREST": {
                "type": 40,
                "name": "Get event interest",
                "description": "<p><strong>Not Mandatory.</strong> Implemented if needed.</p>
                <p>
                    It is possible to ask a node which event(s) it is interested in with this 
                    event.If not implemented the node is supposed to be interested in all events. 
                </p>
                <p>
                    All nodes are by default interested in CLASS1.PROTOCOL. 
                </p>
                <p>
                    The event is intended for very low bandwidth nodes like low power wireless nodes where it saves a lot of 
                    bandwidth if only events that really concerns the node is sent to it. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "GET_EVENT_INTEREST_RESPONSE": {
                "type": 41,
                "name": "Get event interest response",
                "description": "<p><strong>Not mandatory.</strong> Implemented if needed.</p>
                <p>
                    Response for event CLASS1.PROTOCOL, Type = 40. The node report all events it is interested in . 
                </p> 
                <table>
                    <thead>
                    <tr>
                        <th>Data byte</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Index</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>class bit 9 (see table)</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>class 1</td >
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>type 1</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>class 2</td >
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>type 2</td>
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>class 3 </td>
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>type 3</td>
                    </tr> 
                </table>
                <table>
                    <thead>
                    <tr>
                        <th>Bit</th>
                        <th>Description</th>
                    </tr> 
                    </thead> 
                    <tr>
                        <td>0</td>
                        <td>Bit 9 for class 1</td>
                    </tr> 
                    <tr>
                        <td>1</td>
                        <td>Bit 9 for class 2 </td>
                    </tr> 
                    <tr>
                        <td>2</td>
                        <td>Bit 9 for class 3 </td>
                    </tr> 
                    <tr>
                        <td>3</td>
                        <td>All Type 1 is recognized (set type to zero).</td>
                    </tr> 
                    <tr>
                        <td>4</td>
                        <td>All Type 2 is recognized (set type to zero).</td>
                    </tr> 
                    <tr>
                        <td>5</td>
                        <td>All Type 3 is recognized (set type to zero).</td>
                    </tr> 
                    <tr>
                        <td>6</td>
                        <td>0</td>
                    </tr> 
                    <tr>
                        <td>7</td>
                        <td>0</td >
                    </tr> 
                </table>
                <p>
                    A node that is interested in everything send just a CLASS1.PROTOCOL, Type = 41 with no data. 
                </p>
                <p>
                    Nodes that want to specify events of interest fill them in .If all types of a class should be 
                    recognized set the corresponding bit in byte 1 and the related type to zero. 
                </p>
                <p>
                    A maximum of 255 frames(index = 0 - 254) may be sent. 
                </p>
                <p>
                    Fill unused pairs with zero. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 42,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 43,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 44,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 45,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 46,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "reserved": {
                "type": 47,
                "name": "Reserved for future use",
                "description": "",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "ACTIVATE_NEW_IMAGE_ACK": {
                "type": 48,
                "name": "Activate new image ACK",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used. </p>
                <p>
                    Part of the VSCP boot - loader functionality.This is the positive response after a node received a 
                    CLASS1.PROTOCOL, Type = 22, Activate new image.It is sent by the node before the new firmware is booted 
                    into. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "ACTIVATE_NEW_IMAGE_NACK": {
                "type": 49,
                "name": "Activate new image NACK",
                "description": "<p> <strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used. </p>
                <p>
                    Part of the VSCP boot - loader functionality.This is the negative response after a node received a 
                    CLASS1.PROTOCOL, Type = 22, Activate new image.It is sent by the node to inform it that it will(or can not) 
                    switch to the new firmware image. 
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "BLOCK_DATA_TRANSFER_ACK": {
                "type": 50,
                "name": "Block data transfer ACK",
                "description": "<p><strong>Not mandatory </strong> Only needed if a VSCP boot loader algorithm is used.</p>
                <p>
                    Part of the VSCP boot - loader functionality.This is the positive response after a node received a 
                    <strong>CLASS1.PROTOCOL, Type = 16 </strong>, block data transfer. It is sent by the node as a validation 
                    that it can handle the block data transfer.  
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
            "BLOCK_DATA_TRANSFER_NACK": {
                "type": 51,
                "name": "Block data transfer NACK",
                "description": "<p><strong>Not mandatory.</strong> Only needed if a VSCP boot-loader algorithm is used.</p>
                <p>
                    Part of the VSCP boot-loader functionality. This is the negative response after a node received a 
                    <strong>CLASS1.PROTOCOL, Type=16</strong>, block data transfer. It is sent by the node as an indication 
                    that it can NOT handle the block data transfer.
                </p>",
                "data": [{
                    "ordinal": "0",
                    "description": ""
                }, ]
            },
        }
    }

    "CLASS1.ALARM": {
        "vscpclass": 1,
        "description": "Alarm functionality",
        "vscptype": {
            "ALARM_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.SECURITY": {
        "vscpclass": 2,
        "vscpclass512": "CLASS2.CLASS1_SECURITY",
        "description": "Security",
        "vscptype": {
            "SECURITY_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.MEASUREMENT": {
        "vscpclass": 10,
        "description": "Measurement",
        "data": [{
            "ordinal": "0",
            "description": "Data coding byte"
        }, {
            "ordinal": "1..7",
            "description": "1-7 bytes of data with format defined by the data coding byte."
        }],
        "displayvalue": "%vscp-measurement %vscp-unit",
        "htmlinfo": "<strong>Sensor index</strong>: %vscp-sensor<br><strong>Coding</strong>: %vscp-coding (%vscp-coding-text)<br><strong>Value</strong>: %vscp-measurement %vscp-unit<br>"
        "vscptype": {

            "MEASUREMENT_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function.",
                "unit": [],
                "htmlunit": [],
                "unitdescription": []
            },

            "MEASUREMENT_COUNT": {
                "type": 1,
                "description": "This is a discrete value typical for a count. There is no unit for this measurement just a discrete value. ",
                "unit": [],
                "htmlunit": [],
                "unitdescription": []
            },

            "MEASUREMENT_LENGTH": {
                "type": 2,
                "description": "This is a measurement of a length or a distance.",
                "unit": ["m"],
                "htmlunit": ["m"],
                "unitdescription": ["Meter"],
            },

            "MEASUREMENT_MASS": {
                "type": 3,
                "description": "This is a measurement of a mass.",
                "unit": ["kg"],
                "htmlunit": ["kg"],
                "unitdescription": ["Kilogram"],
            },

            "MEASUREMENT_TIME": {
                "type": 4,
                "description": "A time measurement.",
                "unit": ["s", "ms", "", ""],
                "htmlunit": ["s", "ms", "", ""],
                "unitdescription": ["Seconds", "Milliseconds", "Binary: y-y-m-d-h-m-s", "String: 'HHMMSS' "],
            },

            "MEASUREMENT_ELECTRIC_CURRENT": {
                "type": 5,
                "description": "This is a measurement of an electric current.",
                "unit": ["A"],
                "htmlunit": ["A"],
                "unitdescription": ["Ampere"],
            },

            "MEASUREMENT_TEMPERATURE": {
                "type": 6,
                "description": "This is a temperture measurement.",
                "unit": ["K", "C", "F"],
                "htmlunit": ["K", "&#x2103;", "&#x2109;"],
                "unitdescription": ["Degrees Kelvin", "Degrees Celisus", "Degrees Fahrenheit"],
            },

            "MEASUREMENT_AMOUNT_OF_SUBSTANCE": {
                "type": 7,
                "description": "This is a measurement of an amount of a substance.",
                "unit": ["mol"],
                "htmlunit": ["mol"],
                "unitdescription": ["Mole"],
            },

            "MEASUREMENT_INTENSITY_OF_LIGHT": {
                "type": 8,
                "description": "Luminous Intensity (Intensity of light).",
                "unit": ["cd"],
                "htmlunit": ["cd"],
                "unitdescription": ["candela"],
            },

            "MEASUREMENT_FREQUENCY": {
                "type": 9,
                "description": "This is a measurement of regular events during a second, frequency.",
                "unit": ["Hz"],
                "htmlunit": ["Hz"],
                "unitdescription": ["hertz"],
            },

            "MEASUREMENT_RADIOACTIVITY": {
                "type": 10,
                "description": "This is a measurement of rates of things, which happen randomly, or are unpredictable. Typically radioactivity and other random events.",
                "unit": ["Bq", "Ci"],
                "htmlunit": ["Bq", "Ci"],
                "unitdescription": ["becquerel", "curie"],
            },

            "MEASUREMENT_FORCE": {
                "type": 11,
                "description": "This is a measurement of force.",
                "unit": ["N"],
                "htmlunit": ["N"],
                "unitdescription": ["newton"],
            },

            "MEASUREMENT_PRESSURE": {
                "type": 12,
                "description": "This is a measurement of pressure.",
                "unit": ["N", "bar", "psi"],
                "htmlunit": ["N", "bar", "psi"],
                "unitdescription": ["pascal", "bar", "psi"],
            },

            "MEASUREMENT_ENERGY": {
                "type": 13,
                "description": "This is a measurement of energy.",
                "unit": ["J", "KWh"],
                "htmlunit": ["J", "KWh"],
                "unitdescription": ["joule", "KWh"],
            },

            "MEASUREMENT_POWER": {
                "type": 14,
                "description": "This is a measurement of power.",
                "unit": ["W", "hp"],
                "htmlunit": ["W", "hp"],
                "unitdescription": ["watt", "Horse Power"],
            },

            "MEASUREMENT_ELECTRICAL_CHARGE": {
                "type": 15,
                "description": "This is a measurement electrical charge.",
                "unit": ["C"],
                "htmlunit": ["C"],
                "unitdescription": ["coulomb"],
            },

            "MEASUREMENT_ELECTRICAL_POTENTIAL": {
                "type": 16,
                "description": "This is a measurement of electrical potential voltage.",
                "unit": ["V"],
                "htmlunit": ["V"],
                "unitdescription": ["volt"],
            },

            "MEASUREMENT_ELECTRICAL_CAPACITANCE": {
                "type": 17,
                "description": "This is a measurement of electric capacitance.",
                "unit": ["F"],
                "htmlunit": ["F"],
                "unitdescription": ["farad"],
            },

            "MEASUREMENT_ELECTRICAL_RECISTANCE": {
                "type": 18,
                "description": "This is a measurement of resistance.",
                "unit": ["ohm"],
                "htmlunit": ["&#x2126;"],
                "unitdescription": ["ohm"],
            },

            "MEASUREMENT_ELECTRICAL_CONDUCTANCE": {
                "type": 19,
                "description": "This is a measurement of electrical conductance.",
                "unit": ["S"],
                "htmlunit": ["S"],
                "unitdescription": ["siemens"],
            },

            "MEASUREMENT_MAGNETIC_FIELD_STRENGTH": {
                "type": 20,
                "description": "This is a measurement of magnetic field strength.",
                "unit": ["H", "B"],
                "htmlunit": ["H", "B"],
                "unitdescription": ["amperes per meter", "teslas"],
            },

            "MEASUREMENT_MAGNETIC_FLUX": {
                "type": 21,
                "description": "This is a measurement of magnetic flux.",
                "unit": ["Wb"],
                "htmlunit": ["Wb"],
                "unitdescription": ["weber"],
            },

            "MEASUREMENT_MAGNETIC_FLUX_DENSITY": {
                "type": 22,
                "description": "This is a measurement of flux density or field strength for magnetic fields (also called the magnetic induction).",
                "unit": ["B"],
                "htmlunit": ["B"],
                "unitdescription": ["tesla"],
            },

            "MEASUREMENT_INDUCTANCE": {
                "type": 23,
                "description": "This is a measurement of inductance.",
                "unit": ["H"],
                "htmlunit": ["H"],
                "unitdescription": ["hendry"],
            },

            "MEASUREMENT_FLUX_OF_LIGHT": {
                "type": 24,
                "description": "This is a measurement of luminous flux (luminous power).",
                "unit": ["lm"],
                "htmlunit": ["lm"],
                "unitdescription": ["lumen (cd * sr)"],
            },

            "MEASUREMENT_ILLUMINANCE": {
                "type": 25,
                "description": "This is used to express both Illuminance (incidence of light) and Luminous Emittance (emission of light).",
                "unit": ["lx"],
                "htmlunit": ["lx"],
                "unitdescription": ["lux ( lx = lm / m² )"],
            },

            "MEASUREMENT_RADIATION_DOSE": {
                "type": 26,
                "description": "This is a measurement of a radiation dose (Absorbed dose of ionizing radiation).",
                "unit": ["Gy", "Sv"],
                "htmlunit": ["Gy", "Sv"],
                "unitdescription": ["gray", "sievert"],
            },

            "MEASUREMENT_CATALYTIC_ACITIVITY": {
                "type": 27,
                "description": "This is a measurement of catalytic activity used in biochemistry.",
                "unit": ["z"],
                "htmlunit": ["z"],
                "unitdescription": ["katal (mol/s)"],
            },

            "MEASUREMENT_VOLUME": {
                "type": 28,
                "description": "This is a measurement of volume.",
                "unit": ["m3", "l", "dl", "cl", "ml"],
                "htmlunit": ["&#x33a5;", "l", "dl", "cl", "ml"],
                "unitdescription": ["Cubic Meter", "litre (dm³)", "decilitre (100 cm³)", "centilitre (10 cm³)", "millilitre (cm³)"],
            },

            "MEASUREMENT_SOUND_INTENSITY": {
                "type": 29,
                "description": "This is a measurement of sound intensity (acoustic intensity).",
                "unit": ["W/m2"],
                "htmlunit": ["W/&#x33a1;"],
                "unitdescription": ["watt per square meter"],
            },

            "MEASUREMENT_ANGLE": {
                "type": 30,
                "description": "This is a measurement of an angle.",
                "unit": ["rad", "deg", "min", "sec"],
                "htmlunit": ["&#x33ad;", "&#xb0;", "&#x2032;", "&#x2033;"],
                "unitdescription": ["radian", "degree", "arcminute", "arcsecond"],
            },

            "MEASUREMENT_POSITION": {
                "type": 31,
                "description": "This is a measurement of a position as of WGS 84.",
                "unit": ["long", "lat"],
                "htmlunit": ["long", "lat"],
                "unitdescription": ["longitude", "latitude"],
            },

            "MEASUREMENT_SPEED": {
                "type": 32,
                "description": "This is a measurement of a speed.",
                "unit": ["m/s", "km/h", "mph"],
                "htmlunit": ["m/s", "km/h", "mph"],
                "unitdescription": ["Meters per second", "Kilometers per hour", "Miles per hour"],
            },

            "MEASUREMENT_ACCELERATION": {
                "type": 33,
                "description": "This is a measurement of acceleration.",
                "unit": ["m/s2"],
                "htmlunit": ["m/s2"],
                "unitdescription": ["Meters per second second"],
            },

            "MEASUREMENT_TENSION": {
                "type": 34,
                "description": "This is a measurement of tension.",
                "unit": ["N/m"],
                "htmlunit": ["N/m"],
                "unitdescription": ["Newton per meter"],
            },

            "MEASUREMENT_HUMIDITY": {
                "type": 35,
                "description": "Damp/moist (Hygrometer reading).",
                "unit": ["%"],
                "htmlunit": ["%"],
                "unitdescription": ["Relative percentage 0-100%"],
            },

            "MEASUREMENT_FLOW": {
                "type": 36,
                "description": "This is a measurement of flow.",
                "unit": ["m3/s", "l/s"],
                "htmlunit": ["&#x33a5;/s", "l/s"],
                "unitdescription": ["Cubic meters per second", "Liters per second"],
            },

            "MEASUREMENT_THERMAL_RESISTANCE": {
                "type": 37,
                "description": "This is a measurement of flow.",
                "unit": ["K/W"],
                "htmlunit": ["K/W"],
                "unitdescription": ["Kelvin per watt"],
            },

            "MEASUREMENT_REFRACTIVE_POWER": {
                "type": 38,
                "description": "This is a measurement of refractive power.",
                "unit": ["dpt"],
                "htmlunit": ["dpt"],
                "unitdescription": ["dioptre"],
            },

            "MEASUREMENT_DYNAMIC_VISCOSITY": {
                "type": 39,
                "description": "This is a measurement of dynamic viscosity.",
                "unit": ["Pl"],
                "htmlunit": ["Pl"],
                "unitdescription": ["poiseuille"],
            },

            "MEASUREMENT_SOUND_IMPEDANCE": {
                "type": 40,
                "description": "This is a measurement of sound impedance.",
                "unit": ["rayl"],
                "htmlunit": ["rayl"],
                "unitdescription": ["Pa·s/m"],
            },

            "MEASUREMENT_SOUND_RESISTANCE": {
                "type": 41,
                "description": "This is a measurement of sound resistance .",
                "unit": ["Acoustic ohm"],
                "htmlunit": ["Acoustic ohm"],
                "unitdescription": ["Acoustic ohm Pa · s/ m³"],
            },

            "MEASUREMENT_ELECTRIC_ELASTANCE": {
                "type": 42,
                "description": "This is a measurement of sound resistance .",
                "unit": ["F−1"],
                "htmlunit": ["F−1"],
                "unitdescription": ["daraf"],
            },

            "MEASUREMENT_ELECTRIC_ELASTANCE": {
                "type": 43,
                "description": "This is a measurement of luminous energy.",
                "unit": ["tb"],
                "htmlunit": ["tb"],
                "unitdescription": ["talbot"],
            },

            "MEASUREMENT_LUMINANCE": {
                "type": 44,
                "description": "This is a measurement of luminance.",
                "unit": ["cd/m2"],
                "htmlunit": ["cd/m2"],
                "unitdescription": ["candela per square metre"],
            },

            "MEASUREMENT_CHEMICAL_CONCENTRATION": {
                "type": 45,
                "description": "Chemical concentration",
                "unit": ["molal"],
                "htmlunit": ["molal"],
                "unitdescription": ["mol per kg"],
            },

            "MEASUREMENT_RESERVED1": {
                "type": 46,
                "description": "Reserved",
                "unit": [],
                "htmlunit": [],
                "unitdescription": [],
            },

            "MEASUREMENT_DOSE_EQVIVALENT": {
                "type": 47,
                "description": "This is a measurement of dose equivalent.",
                "unit": ["sievert"],
                "htmlunit": ["sievert"],
                "unitdescription": ["joule per kilo"],
            },

            "MEASUREMENT_RESERVED2": {
                "type": 48,
                "description": "Reserved",
                "unit": [],
                "htmlunit": [],
                "unitdescription": [],
            },

            "MEASUREMENT_DEWPOINT": {
                "type": 49,
                "description": "This is a measurement of the Dew Point. ",
                "unit": ["K", "C", "F"],
                "htmlunit": ["K", "&#x2103;", "&#x2109;"],
                "unitdescription": ["Degrees Kelvin", "Degrees Celisus", "Degrees Fahrenheit"],
            },

            "MEASUREMENT_RELATIVE_LEVEL": {
                "type": 50,
                "description": "This is a relative value for a level measurement without a unit. It is just relative to the min/max value for the selected data representation. , typically percentage or per mille or similar",
                "unit": ["K", "C", "F"],
                "htmlunit": ["K", "&#x2103;", "&#x2109;"],
                "unitdescription": ["Relative value"],
            },

            "MEASUREMENT_ALTITUDE": {
                "type": 51,
                "description": "This is a measurement of the Dew Point.",
                "unit": ["m", "ft", "in"],
                "htmlunit": ["m", "ft", "in"],
                "unitdescription": ["meters", "feet", "inches"],
            },

            "MEASUREMENT_AREA": {
                "type": 52,
                "description": "Altitude in meters.",
                "unit": ["m2"],
                "htmlunit": ["&#x33a1;"],
                "unitdescription": ["Square meters"],
            },

            "MEASUREMENT_RADIANT_INTENSITY": {
                "type": 53,
                "description": "Radiated power per room angle.",
                "unit": ["W/sr"],
                "htmlunit": ["W/sr"],
                "unitdescription": ["watt per steradian"],
            },

            "MEASUREMENT_RADIANCE": {
                "type": 54,
                "description": "This is the radiant flux emitted, reflected, transmitted or received by a surface.",
                "unit": [" W/(sr * m2)"],
                "htmlunit": [" W / (sr * &#x33a1;)"],
                "unitdescription": ["watt per steradian per square metre"],
            },

            "MEASUREMENT_IRRADIANCE": {
                "type": 55,
                "description": "Power emitted from or striking onto a surface or area. ",
                "unit": [" W/m2"],
                "htmlunit": [" W/&#x33a1;"],
                "unitdescription": ["watt per square metre"],
            },

            "MEASUREMENT_SPECTRAL_RADIANCE": {
                "type": 56,
                "description": "Radiance of a surface per unit frequency or wavelength.",
                "unit": [" W/m2", "W·sr-1·m-3", "W·sr-1·m-3"],
                "htmlunit": [" W/&#x33a1;", "W·sr-1·m-3", "W·sr-1·m-3"],
                "unitdescription": ["watt per square metre", "watt per steradian per meter3", "watt per steradian per square metre per hertz"],
            },

            "MEASUREMENT_SOUND_IRRADIANCE": {
                "type": 57,
                "description": "Irradiance of a surface per unit frequency or wavelength.",
                "unit": ["W·m-2·nm-1", "W·m-3", "W·m-2·Hz-1"],
                "htmlunit": ["W·m-2·nm-1", "W·m-3", "W·m-2·Hz-1"],
                "unitdescription": ["watt per square metre per nm", "watt per metre3", "watt per square metre per hertz"],
            },

            "MEASUREMENT_SOUND_PRESSURE": {
                "type": 58,
                "description": "This is a measurement of sound pressure (acoustic pressure).",
                "unit": ["Pa"],
                "htmlunit": ["Pa"],
                "unitdescription": ["pascal"],
            },

            "MEASUREMENT_SOUND_DENSITY": {
                "type": 59,
                "description": "Sound energy density or sound density is the sound energy per unit volume. ",
                "unit": ["Pa"],
                "htmlunit": ["Pa"],
                "unitdescription": ["pascal"],
            },

            "MEASUREMENT_SOUND_LEVEL": {
                "type": 60,
                "description": "Sound level expressed in decibel. This event is supplied for convenience.",
                "unit": ["dB"],
                "htmlunit": ["dB"],
                "unitdescription": ["decibel"],
            },
        }
    }

    "CLASS1.DATA": {
        "vscpclass": 15,
        "vscpclass512": "CLASS2.CLASS1_DATA",
        "description": "Data",
        "vscptype": {
            "DATA_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.INFORMATION": {
        "vscpclass": 20,
        "vscpclass512": "CLASS2.CLASS1_INFORMATION",
        "description": "Information",
        "vscptype": {
            "INFORMATION_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.CONTROL": {
        "vscpclass": 30,
        "vscpclass512": "CLASS2.CLASS1_CONTROL",
        "description": "Control",
        "vscptype": {
            "CONTROL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.MULTIMEDIA": {
        "vscpclass": 40,
        "vscpclass512": "CLASS2.CLASS1_MULTIMEDIA",
        "description": "Multimedia",
        "vscptype": {
            "MULTIMEDIA_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.AOL": {
        "vscpclass": 50,
        "vscpclass512": "CLASS2.CLASS1_AOL",
        "description": "Alert On LAN",
        "vscptype": {
            "AOL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.MEASUREMENT64": {
        "vscpclass": 60,
        "vscpclass512": "CLASS2.CLASS1_MEASUREMENT64",
        "description": "Double precision floating point measurement",
        "vscptype": {
            "MEASUREMENT64_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.MEASUREZONE": {
        "vscpclass": 65,
        "vscpclass512": "CLASS2.CLASS1_MEASUREZONE",
        "description": "Measurement with zone",
        "vscptype": {
            "MEASUREZONE_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.MEASUREMENT32": {
        "vscpclass": 70,
        "vscpclass512": "CLASS2.CLASS1_MEASUREMENT32",
        "description": "Single precision floating point measurement",
        "vscptype": {
            "MEASUREMENT32_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.SETVALUEZONE": {
        "vscpclass": 85,
        "vscpclass512": "CLASS2.CLASS1_SETVALUEZONE",
        "description": "Set value with zone",
        "vscptype": {
            "SETVALUEZONE_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.WEATHER": {
        "vscpclass": 90,
        "vscpclass512": "CLASS2.CLASS1_WEATHER",
        "description": "Weather",
        "vscptype": {
            "WEATHER_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.WEATHER_FORECAST": {
        "vscpclass": 95,
        "vscpclass512": "CLASS2.CLASS1_WEATHER_FORECAST",
        "description": "Weather forecast",
        "vscptype": {
            "WEATHER_FORECASTGENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.PHONE": {
        "vscpclass": 100,
        "vscpclass512": "CLASS2.CLASS1_PHONE",
        "description": "Phone",
        "vscptype": {
            "PHONE_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.DISPLAY": {
        "vscpclass": 102,
        "vscpclass512": "CLASS2.CLASS1_DISPLAY",
        "description": "Display",
        "vscptype": {
            "DISPLAY_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.REMOTE": {
        "vscpclass": 110,
        "vscpclass512": "CLASS2.CLASS1_REMOTE",
        "description": "Remote control functionality",
        "vscptype": {
            "REMOTE_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.GPS": {
        "vscpclass": 206,
        "vscpclass512": "CLASS2.CLASS1_GPS",
        "description": "",
        "vscptype": {
            "GPS_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.WIRELESS": {
        "vscpclass": 212,
        "vscpclass512": "CLASS2.CLASS1_WIRELESS",
        "description": "",
        "vscptype": {
            "WIRELESS_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.DIAGNOSTIC": {
        "vscpclass": 506,
        "vscpclass512": "CLASS2.CLASS1_DIAGNOSTIC",
        "description": "",
        "vscptype": {
            "DIAGNOSTIC_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.ERROR": {
        "vscpclass": 508,
        "vscpclass512": "CLASS2.CLASS1_ERROR",
        "description": "",
        "vscptype": {
            "ERROR_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.LOG": {
        "vscpclass": 509,
        "vscpclass512": "CLASS2.CLASS1_LOG",
        "description": "",
        "vscptype": {
            "LOG_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.LAB": {
        "vscpclass": 510,
        "vscpclass512": "CLASS2.CLASS1_LAB",
        "description": "",
        "vscptype": {
            "LAB_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS1.LOCAL": {
        "vscpclass": 511,
        "vscpclass512": "CLASS2.LEVEL1_LOCAL",
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.PROTOCOL": {
        "vscpclass": 1024,
        "description": "Level II protocol functionality",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.CONTROL": {
        "vscpclass": 1025,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.INFORMATION": {
        "vscpclass": 1026,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }


    "CLASS2.TEXT2SPEECH": {
        "vscpclass": 1028,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.CUSTOM": {
        "vscpclass": 1029,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.DISPLAY": {
        "vscpclass": 1030,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.MEASUREMENT_STR": {
        "vscpclass": 1040,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.MEASUREMENT_FLOAT": {
        "vscpclass": 1060,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

    "CLASS2.MEASUREMENT_VSCPD": {
        "vscpclass": 1060,
        "description": "",
        "vscptype": {
            "LOCAL_GENERAL": {
                "type": 0,
                "description": "Undefined protocol function."
            },
        }
    }

}