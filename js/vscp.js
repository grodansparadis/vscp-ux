//
// VSCP javascript websocket library
// Copyright (C) 2012-2016 Ake Hedman, Grodans Paradis AB
// <akhe@grodansparadis.com>
// Copyright (c) 2015 Andreas Merkle
// <vscp@blue-andi.de>
//
// Licence:
// The MIT License (MIT)
// [OSI Approved License]
//
// The MIT License (MIT)
//
// Copyright (c) 2012-2016 Grodans Paradis AB (Paradise of the Frog)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// Alternative licenses for VSCP & Friends may be arranged by contacting
// Grodans Paradis AB at info@grodansparadis.com, http://www.grodansparadis.com
//

/*jshint bitwise: false */

/** Namespace for all functionality of the VSCP provided libraries.
 * @namespace vscp
 */
var vscp = vscp || {};

/** VSCP websocket library version
 * @property {number} major     - Major version number
 * @property {number} minor     - Minor version number
 * @property {number} subMinor  - Sub-minor version number
 */
vscp.version = {
    major: 0,
    minor: 1,
    subMinor: 0
};

/** Create a general purpose namespace method. This will allow us to create
 * namespace a bit easier.
 *
 * @param {string} namespace Complete namespace, e.g. "a.b.c.d"
 */
vscp._createNS = function ( namespace ) {
    var nsparts = namespace.split(".");
    var parent = vscp;

    /* We want to be able to include or exclude the root namespace .
     * So we strip it if it's in the namespace.
     */
    if ( nsparts[ 0 ] === "vscp" ) {
        nsparts = nsparts.slice( 1 );
    }

    /* Loop through the parts and create a nested namespace if necessary */
    for ( var i = 0; i < nsparts.length; i++ ) {
        var partname = nsparts[ i ];

        /* Check if the current parent already has the namespace declared, if
         * not create it.
         */
        if ( "undefined" === typeof parent[ partname ] ) {
            parent[ partname ] = {};
        }

        /* Get a reference to the deepest element in the hierarchy so far */
        parent = parent[ partname ];
    }

    /* The parent is now completely constructed with empty namespaces and can be used. */
    return parent;
};

/** VSCP constants
 * @namespace vscp.constants
 */
vscp._createNS( "vscp.constants" );

/** VSCP classes
 * @enum {number}
 * @const
 */
vscp.constants.classes = {

    VSCP_CLASS1_PROTOCOL: 0,
    VSCP_CLASS1_ALARM: 1,
    VSCP_CLASS1_SECURITY: 2,
    VSCP_CLASS1_MEASUREMENT: 10,
    VSCP_CLASS1_DATA: 15,
    VSCP_CLASS1_INFORMATION: 20,
    VSCP_CLASS1_CONTROL: 30,
    VSCP_CLASS1_MULTIMEDIA: 40,
    VSCP_CLASS1_AOL: 50,
    VSCP_CLASS1_MEASUREMENT64: 60,
    VSCP_CLASS1_MEASUREZONE: 65,
    VSCP_CLASS1_MEASUREMENT32: 70,
    VSCP_CLASS1_SETVALUEZONE: 85,
    VSCP_CLASS1_WEATHER: 90,
    VSCP_CLASS1_WEATHER_FORECAST: 95,
    VSCP_CLASS1_PHONE: 100,
    VSCP_CLASS1_LIN: 101,
    VSCP_CLASS1_DISPLAY: 102,
    VSCP_CLASS1_REMOTE: 110,

    // 200-205 has been deprecated
    VSCP_CLASS1_ONEWIRE: 200,
    VSCP_CLASS1_X10: 201,
    VSCP_CLASS1_LON: 202,
    VSCP_CLASS1_EIB: 203,
    VSCP_CLASS1_SNAP: 204,
    VSCP_CLASS1_MUMIN: 205,

    VSCP_CLASS1_GPS: 206,
    VSCP_CLASS1_WIRELESS: 212,
    VSCP_CLASS1_DIAGNOSTIC: 506,
    VSCP_CLASS1_ERROR: 508,
    VSCP_CLASS1_LOG: 509,
    VSCP_CLASS1_LAB: 510,
    VSCP_CLASS1_LOCAL: 511,

    // Level I classes on Level II

    VSCP_CLASS2_LEVEL1_PROTOCOL: ( 512 + 0 ),
    VSCP_CLASS2_LEVEL1_ALARM: ( 512 + 1 ),
    VSCP_CLASS2_LEVEL1_SECURITY: ( 512 + 2 ),
    VSCP_CLASS2_LEVEL1_MEASUREMENT: ( 512 + 10 ),
    VSCP_CLASS2_LEVEL1_DATA: ( 512 + 15 ),
    VSCP_CLASS2_LEVEL1_INFORMATION: ( 512 + 20 ),
    VSCP_CLASS2_LEVEL1_CONTROL: ( 512 + 30 ),
    VSCP_CLASS2_LEVEL1_MULTIMEDIA: ( 512 + 40 ),
    VSCP_CLASS2_LEVEL1_AOL: ( 512 + 50 ),
    VSCP_CLASS2_MEASUREMENT64: ( 512 + 60 ),
    VSCP_CLASS2_MEASUREZONE: ( 512 + 65 ),
    VSCP_CLASS2_MEASUREMENT32: ( 512 + 70 ),
    VSCP_CLASS2_SETVALUEZONE: ( 512 + 85 ),
    VSCP_CLASS2_LEVEL1_PHONE: ( 512 + 100 ),
    VSCP_CLASS2_LEVEL1_LIN: ( 512 + 101 ),
    VSCP_CLASS2_LEVEL1_REMOTE: ( 512 + 110 ),
    VSCP_CLASS2_LEVEL1_GPS: ( 512 + 206 ),
    VSCP_CLASS2_LEVEL1_WIRELESS: ( 512 + 212 ),
    VSCP_CLASS2_LEVEL1_LOG: ( 512 + 509 ),
    VSCP_CLASS2_LEVEL1_LAB: ( 512 + 510 ),
    VSCP_CLASS2_LEVEL1_LOCAL: ( 512 + 511 ),

    // Level II classes
    VSCP_CLASS2_PROTOCOL: ( 1024 ),
    VSCP_CLASS2_CONTROL: ( 1025 ),
    VSCP_CLASS2_INFORMATION: ( 1026 ),
    VSCP_CLASS2_TEXT2SPEECH: ( 1028 ),
    VSCP_CLASS2_CUSTOM: ( 1029 ),
    VSCP_CLASS2_DISPLAY: ( 1030 ),
    VSCP_CLASS2_MEASUREMENT_STR: ( 1040 ),
    VSCP_CLASS2_MEASUREMENT_FLOAT: ( 1060 ),
    VSCP_CLASS2_VSCPD: ( 65535 )
};

/** VSCP class types
 * @enum {number}
 * @const
 */
vscp.constants.types = {

    VSCP_TYPE_UNDEFINED: 0,

    // VSCP Protocol Functionality
    VSCP_TYPE_PROTOCOL_SEGCTRL_HEARTBEAT: 1,
    VSCP_TYPE_PROTOCOL_NEW_NODE_ONLINE: 2,
    VSCP_TYPE_PROTOCOL_PROBE_ACK: 3,
    VSCP_TYPE_PROTOCOL_SET_NICKNAME: 6,
    VSCP_TYPE_PROTOCOL_NICKNAME_ACCEPTED: 7,
    VSCP_TYPE_PROTOCOL_DROP_NICKNAME: 8,
    VSCP_TYPE_PROTOCOL_READ_REGISTER: 9,
    VSCP_TYPE_PROTOCOL_RW_RESPONSE: 10,
    VSCP_TYPE_PROTOCOL_WRITE_REGISTER: 11,
    VSCP_TYPE_PROTOCOL_ENTER_BOOT_LOADER: 12,
    VSCP_TYPE_PROTOCOL_ACK_BOOT_LOADER: 13,
    VSCP_TYPE_PROTOCOL_NACK_BOOT_LOADER: 14,
    VSCP_TYPE_PROTOCOL_START_BLOCK: 15,
    VSCP_TYPE_PROTOCOL_BLOCK_DATA: 16,
    VSCP_TYPE_PROTOCOL_BLOCK_DATA_ACK: 17,
    VSCP_TYPE_PROTOCOL_BLOCK_DATA_NACK: 18,
    VSCP_TYPE_PROTOCOL_PROGRAM_BLOCK_DATA: 19,
    VSCP_TYPE_PROTOCOL_PROGRAM_BLOCK_DATA_ACK: 20,
    VSCP_TYPE_PROTOCOL_PROGRAM_BLOCK_DATA_NACK: 21,
    VSCP_TYPE_PROTOCOL_ACTIVATE_NEW_IMAGE: 22,
    VSCP_TYPE_PROTOCOL_RESET_DEVICE: 23,
    VSCP_TYPE_PROTOCOL_PAGE_READ: 24,
    VSCP_TYPE_PROTOCOL_PAGE_WRITE: 25,
    VSCP_TYPE_PROTOCOL_RW_PAGE_RESPONSE: 26,
    VSCP_TYPE_PROTOCOL_HIGH_END_SERVER_PROBE: 27,
    VSCP_TYPE_PROTOCOL_HIGH_END_SERVER_RESPONSE: 28,
    VSCP_TYPE_PROTOCOL_INCREMENT_REGISTER: 29,
    VSCP_TYPE_PROTOCOL_DECREMENT_REGISTER: 30,
    VSCP_TYPE_PROTOCOL_WHO_IS_THERE: 31,
    VSCP_TYPE_PROTOCOL_WHO_IS_THERE_RESPONSE: 32,
    VSCP_TYPE_PROTOCOL_GET_MATRIX_INFO: 33,
    VSCP_TYPE_PROTOCOL_GET_MATRIX_INFO_RESPONSE: 34,
    VSCP_TYPE_PROTOCOL_GET_EMBEDDED_MDF: 35,
    VSCP_TYPE_PROTOCOL_GET_EMBEDDED_MDF_RESPONSE: 36,
    VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_READ: 37,
    VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_WRITE: 38,
    VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_RESPONSE: 39,
    VSCP_TYPE_PROTOCOL_GET_EVENT_INTEREST: 40,
    VSCP_TYPE_PROTOCOL_GET_EVENT_INTEREST_RESPONSE: 41,
    VSCP_TYPE_PROTOCOL_ACTIVATE_NEW_IMAGE_ACK: 48,
    VSCP_TYPE_PROTOCOL_ACTIVATE_NEW_IMAGE_NACK: 49,
    VSCP_TYPE_PROTOCOL_START_BLOCK_ACK: 50,
    VSCP_TYPE_PROTOCOL_START_BLOCK_NACK: 51,

    // Class 1 (0x01) -- ALARM
    VSCP_TYPE_ALARM_GENERAL: 0,
    VSCP_TYPE_ALARM_WARNING: 1,
    VSCP_TYPE_ALARM_ALARM: 2,
    VSCP_TYPE_ALARM_SOUND: 3,
    VSCP_TYPE_ALARM_LIGHT: 4,
    VSCP_TYPE_ALARM_POWER: 5,
    VSCP_TYPE_ALARM_EMERGENCY_STOP: 6,
    VSCP_TYPE_ALARM_EMERGENCY_PAUSE: 7,
    VSCP_TYPE_ALARM_EMERGENCY_RESET: 8,
    VSCP_TYPE_ALARM_EMERGENCY_RESUME: 9,

    // Class 2 (0x02) -- SECURITY
    VSCP_TYPE_SECURITY_GENERAL: 0,
    VSCP_TYPE_SECURITY_MOTION: 1,
    VSCP_TYPE_SECURITY_GLASS_BREAK: 2,
    VSCP_TYPE_SECURITY_BEAM_BREAK: 3,
    VSCP_TYPE_SECURITY_SENSOR_TAMPER: 4,
    VSCP_TYPE_SECURITY_SHOCK_SENSOR: 5,
    VSCP_TYPE_SECURITY_SMOKE_SENSOR: 6,
    VSCP_TYPE_SECURITY_HEAT_SENSOR: 7,
    VSCP_TYPE_SECURITY_PANIC_SWITCH: 8,
    VSCP_TYPE_SECURITY_DOOR_OPEN: 9,
    VSCP_TYPE_SECURITY_WINDOW_OPEN: 10,
    VSCP_TYPE_SECURITY_CO_SENSOR: 11,
    VSCP_TYPE_SECURITY_FROST_DETECTED: 12,
    VSCP_TYPE_SECURITY_FLAME_DETECTED: 13,
    VSCP_TYPE_SECURITY_OXYGEN_LOW: 14,
    VSCP_TYPE_SECURITY_WEIGHT_DETECTED: 15,
    VSCP_TYPE_SECURITY_WATER_DETECTED: 16,
    VSCP_TYPE_SECURITY_CONDENSATION_DETECTED: 17,
    VSCP_TYPE_SECURITY_SOUND_DETECTED: 18,
    VSCP_TYPE_SECURITY_HARMFUL_SOUND_LEVEL: 19,
    VSCP_TYPE_SECURITY_TAMPER: 20,

    // Class 10 (0x0a) -- MEASUREMENT
    VSCP_TYPE_MEASUREMENT_GENERAL: 0,
    VSCP_TYPE_MEASUREMENT_COUNT: 1,
    VSCP_TYPE_MEASUREMENT_LENGTH: 2,
    VSCP_TYPE_MEASUREMENT_MASS: 3,
    VSCP_TYPE_MEASUREMENT_TIME: 4,
    VSCP_TYPE_MEASUREMENT_ELECTRIC_CURRENT: 5,
    VSCP_TYPE_MEASUREMENT_TEMPERATURE: 6,
    VSCP_TYPE_MEASUREMENT_AMOUNT_OF_SUBSTANCE: 7,
    VSCP_TYPE_MEASUREMENT_INTENSITY_OF_LIGHT: 8,
    VSCP_TYPE_MEASUREMENT_FREQUENCY: 9,
    VSCP_TYPE_MEASUREMENT_RADIOACTIVITY: 10,
    VSCP_TYPE_MEASUREMENT_FORCE: 11,
    VSCP_TYPE_MEASUREMENT_PRESSURE: 12,
    VSCP_TYPE_MEASUREMENT_ENERGY: 13,
    VSCP_TYPE_MEASUREMENT_POWER: 14,
    VSCP_TYPE_MEASUREMENT_ELECTRICAL_CHARGE: 15,
    VSCP_TYPE_MEASUREMENT_ELECTRICAL_POTENTIAL: 16,
    VSCP_TYPE_MEASUREMENT_ELECTRICAL_CAPACITANCE: 17,
    VSCP_TYPE_MEASUREMENT_ELECTRICAL_RECISTANCE: 18,
    VSCP_TYPE_MEASUREMENT_ELECTRICAL_CONDUCTANCE: 19,
    VSCP_TYPE_MEASUREMENT_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP_TYPE_MEASUREMENT_MAGNETIC_FLUX: 21,
    VSCP_TYPE_MEASUREMENT_MAGNETIC_FLUX_DENSITY: 22,
    VSCP_TYPE_MEASUREMENT_INDUCTANCE: 23,
    VSCP_TYPE_MEASUREMENT_FLUX_OF_LIGHT: 24,
    VSCP_TYPE_MEASUREMENT_ILLUMINANCE: 25,
    VSCP_TYPE_MEASUREMENT_RADIATION_DOSE: 26,
    VSCP_TYPE_MEASUREMENT_CATALYTIC_ACITIVITY: 27,
    VSCP_TYPE_MEASUREMENT_VOLUME: 28,
    VSCP_TYPE_MEASUREMENT_SOUND_INTENSITY: 29,
    VSCP_TYPE_MEASUREMENT_ANGLE: 30,
    VSCP_TYPE_MEASUREMENT_POSITION: 31,
    VSCP_TYPE_MEASUREMENT_SPEED: 32,
    VSCP_TYPE_MEASUREMENT_ACCELERATION: 33,
    VSCP_TYPE_MEASUREMENT_TENSION: 34,
    VSCP_TYPE_MEASUREMENT_HUMIDITY: 35,
    VSCP_TYPE_MEASUREMENT_FLOW: 36,
    VSCP_TYPE_MEASUREMENT_THERMAL_RESISTANCE: 37,
    VSCP_TYPE_MEASUREMENT_REFRACTIVE_POWER: 38,
    VSCP_TYPE_MEASUREMENT_DYNAMIC_VISCOSITY: 39,
    VSCP_TYPE_MEASUREMENT_SOUND_IMPEDANCE: 40,
    VSCP_TYPE_MEASUREMENT_SOUND_RESISTANCE: 41,
    VSCP_TYPE_MEASUREMENT_ELECTRIC_ELASTANCE: 42,
    VSCP_TYPE_MEASUREMENT_LUMINOUS_ENERGY: 43,
    VSCP_TYPE_MEASUREMENT_LUMINANCE: 44,
    VSCP_TYPE_MEASUREMENT_CHEMICAL_CONCENTRATION: 45,
    VSCP_TYPE_MEASUREMENT_RESERVED: 46,
    VSCP_TYPE_MEASUREMENT_DOSE_EQVIVALENT: 47,
    VSCP_TYPE_MEASUREMENT_DEWPOINT: 49,
    VSCP_TYPE_MEASUREMENT_RELATIVE_LEVEL: 50,
    VSCP_TYPE_MEASUREMENT_ALTITUDE: 51,
    VSCP_TYPE_MEASUREMENT_AREA: 52,
    VSCP_TYPE_MEASUREMENT_RADIANT_INTENSITY: 53,
    VSCP_TYPE_MEASUREMENT_RADIANCE: 54,
    VSCP_TYPE_MEASUREMENT_IRRADIANCE: 55,
    VSCP_TYPE_MEASUREMENT_SPECTRAL_RADIANCE: 56,
    VSCP_TYPE_MEASUREMENT_SPECTRAL_IRRADIANCE: 57,


    // Class 15 (0x0f) -- DATA
    VSCP_TYPE_DATA_GENERAL: 0,
    VSCP_TYPE_DATA_IO: 1,
    VSCP_TYPE_DATA_AD: 2,
    VSCP_TYPE_DATA_DA: 3,
    VSCP_TYPE_DATA_RELATIVE_STRENGTH: 4,
    VSCP_TYPE_DATA_SIGNAL_LEVEL: 5,
    VSCP_TYPE_DATA_SIGNAL_QUALITY: 6,

    // class 20 (0x14) -- INFORMATION
    VSCP_TYPE_INFORMATION_GENERAL: 0,
    VSCP_TYPE_INFORMATION_BUTTON: 1,
    VSCP_TYPE_INFORMATION_MOUSE: 2,
    VSCP_TYPE_INFORMATION_ON: 3,
    VSCP_TYPE_INFORMATION_OFF: 4,
    VSCP_TYPE_INFORMATION_ALIVE: 5,
    VSCP_TYPE_INFORMATION_TERMINATING: 6,
    VSCP_TYPE_INFORMATION_OPENED: 7,
    VSCP_TYPE_INFORMATION_CLOSED: 8,
    VSCP_TYPE_INFORMATION_NODE_HEARTBEAT: 9,
    VSCP_TYPE_INFORMATION_BELOW_LIMIT: 10,
    VSCP_TYPE_INFORMATION_ABOVE_LIMIT: 11,
    VSCP_TYPE_INFORMATION_PULSE: 12,
    VSCP_TYPE_INFORMATION_ERROR: 13,
    VSCP_TYPE_INFORMATION_RESUMED: 14,
    VSCP_TYPE_INFORMATION_PAUSED: 15,
    VSCP_TYPE_INFORMATION_SLEEP: 16,
    VSCP_TYPE_INFORMATION_GOOD_MORNING: 17,
    VSCP_TYPE_INFORMATION_GOOD_DAY: 18,
    VSCP_TYPE_INFORMATION_GOOD_AFTERNOON: 19,
    VSCP_TYPE_INFORMATION_GOOD_EVENING: 20,
    VSCP_TYPE_INFORMATION_GOOD_NIGHT: 21,
    VSCP_TYPE_INFORMATION_SEE_YOU_SOON: 22,
    VSCP_TYPE_INFORMATION_GOODBYE: 23,
    VSCP_TYPE_INFORMATION_STOP: 24,
    VSCP_TYPE_INFORMATION_START: 25,
    VSCP_TYPE_INFORMATION_RESET_COMPLETED: 26,
    VSCP_TYPE_INFORMATION_INTERRUPTED: 27,
    VSCP_TYPE_INFORMATION_PREPARING_TO_SLEEP: 28,
    VSCP_TYPE_INFORMATION_WOKEN_UP: 29,
    VSCP_TYPE_INFORMATION_DUSK: 30,
    VSCP_TYPE_INFORMATION_DAWN: 31,
    VSCP_TYPE_INFORMATION_ACTIVE: 32,
    VSCP_TYPE_INFORMATION_INACTIVE: 33,
    VSCP_TYPE_INFORMATION_BUSY: 34,
    VSCP_TYPE_INFORMATION_IDLE: 35,
    VSCP_TYPE_INFORMATION_STREAM_DATA: 36,
    VSCP_TYPE_INFORMATION_TOKEN_ACTIVITY: 37,
    VSCP_TYPE_INFORMATION_STREAM_DATA_WITH_ZONE: 38,
    VSCP_TYPE_INFORMATION_CONFIRM: 39,
    VSCP_TYPE_INFORMATION_LEVEL_CHANGED: 40,
    VSCP_TYPE_INFORMATION_WARNING: 41,
    VSCP_TYPE_INFORMATION_STATE: 42,
    VSCP_TYPE_INFORMATION_ACTION_TRIGGER: 43,
    VSCP_TYPE_INFORMATION_SUNRISE: 44,
    VSCP_TYPE_INFORMATION_SUNSET: 45,
    VSCP_TYPE_INFORMATION_START_OF_RECORD: 46,
    VSCP_TYPE_INFORMATION_END_OF_RECORD: 47,
    VSCP_TYPE_INFORMATION_PRESET_ACTIVE: 48,
    VSCP_TYPE_INFORMATION_DETECT: 49,
    VSCP_TYPE_INFORMATION_OVERFLOW: 50,
    VSCP_TYPE_INFORMATION_BIG_LEVEL_CHANGED: 51,
    VSCP_TYPE_INFORMATION_SUNRISE_TWILIGHT_START: 52,
    VSCP_TYPE_INFORMATION_SUNSET_TWILIGHT_START: 53,
    VSCP_TYPE_INFORMATION_NAUTICAL_SUNRISE_TWILIGHT_START: 54,
    VSCP_TYPE_INFORMATION_NAUTICAL_SUNSET_TWILIGHT_START: 55,
    VSCP_TYPE_INFORMATION_ASTRONOMICAL_SUNRISE_TWILIGHT_START: 56,
    VSCP_TYPE_INFORMATION_ASTRONOMICAL_SUNSET_TWILIGHT_START: 57,
    VSCP_TYPE_INFORMATION_CALCULATED_NOON: 58,
    VSCP_TYPE_INFORMATION_SHUTTER_UP: 59,
    VSCP_TYPE_INFORMATION_SHUTTER_DOWN: 60,
    VSCP_TYPE_INFORMATION_SHUTTER_LEFT: 61,
    VSCP_TYPE_INFORMATION_SHUTTER_RIGHT: 62,
    VSCP_TYPE_INFORMATION_SHUTTER_END_TOP: 63,
    VSCP_TYPE_INFORMATION_SHUTTER_END_BOTTOM: 64,
    VSCP_TYPE_INFORMATION_SHUTTER_END_MIDDLE: 65,
    VSCP_TYPE_INFORMATION_SHUTTER_END_PRESET: 66,
    VSCP_TYPE_INFORMATION_SHUTTER_END_LEFT: 67,
    VSCP_TYPE_INFORMATION_SHUTTER_END_RIGHT: 68,
    VSCP_TYPE_INFORMATION_LONG_CLICK: 69,
    VSCP_TYPE_INFORMATION_SINGLE_CLICK: 70,
    VSCP_TYPE_INFORMATION_DOUBLE_CLICK: 71,

    // class 30 (0x1E) -- CONTROL
    VSCP_TYPE_CONTROL_GENERAL: 0,
    VSCP_TYPE_CONTROL_MUTE: 1,
    VSCP_TYPE_CONTROL_ALL_LAMPS: 2,
    VSCP_TYPE_CONTROL_OPEN: 3,
    VSCP_TYPE_CONTROL_CLOSE: 4,
    VSCP_TYPE_CONTROL_TURNON: 5,
    VSCP_TYPE_CONTROL_TURNOFF: 6,
    VSCP_TYPE_CONTROL_START: 7,
    VSCP_TYPE_CONTROL_STOP: 8,
    VSCP_TYPE_CONTROL_RESET: 9,
    VSCP_TYPE_CONTROL_INTERRUPT: 10,
    VSCP_TYPE_CONTROL_SLEEP: 11,
    VSCP_TYPE_CONTROL_WAKEUP: 12,
    VSCP_TYPE_CONTROL_RESUME: 13,
    VSCP_TYPE_CONTROL_PAUSE: 14,
    VSCP_TYPE_CONTROL_ACTIVATE: 15,
    VSCP_TYPE_CONTROL_DEACTIVATE: 16,
    VSCP_TYPE_CONTROL_DIM_LAMPS: 20,
    VSCP_TYPE_CONTROL_CHANGE_CHANNEL: 21,
    VSCP_TYPE_CONTROL_CHANGE_LEVEL: 22,
    VSCP_TYPE_CONTROL_RELATIVE_CHANGE_LEVEL: 23,
    VSCP_TYPE_CONTROL_MEASUREMENT_REQUEST: 24,
    VSCP_TYPE_CONTROL_STREAM_DATA: 25,
    VSCP_TYPE_CONTROL_SYNC: 26,
    VSCP_TYPE_CONTROL_ZONED_STREAM_DATA: 27,
    VSCP_TYPE_CONTROL_SET_PRESET: 28,
    VSCP_TYPE_CONTROL_TOGGLE_STATE: 29,
    VSCP_TYPE_CONTROL_TIMED_PULE_ON: 30,
    VSCP_TYPE_CONTROL_TIMED_PULSE_OFF: 31,
    VSCP_TYPE_CONTROL_SET_COUNTRY_LANGUAGE: 32,
    VSCP_TYPE_CONTROL_BIG_CHANGE_LEVEL: 33,
    VSCP_TYPE_CONTROL_SHUTTER_UP: 34,
    VSCP_TYPE_CONTROL_SHUTTER_DOWN: 35,
    VSCP_TYPE_CONTROL_SHUTTER_LEFT: 36,
    VSCP_TYPE_CONTROL_SHUTTER_RIGHT: 37,
    VSCP_TYPE_CONTROL_SHUTTER_MIDDLE: 38,
    VSCP_TYPE_CONTROL_SHUTTER_PRESET: 39,
    VSCP_TYPE_CONTROL_ALL_LAMPS_ON: 40,
    VSCP_TYPE_CONTROL_ALL_LAMPS_OFF: 41,

    // class 40 (0x28) -- MULTIMEDIA
    VSCP_TYPE_MULTIMEDIA_GENERAL: 0,
    VSCP_TYPE_MULTIMEDIA_PLAYBACK: 1,
    VSCP_TYPE_MULTIMEDIA_NAVIGATOR_KEY_ENG: 2,
    VSCP_TYPE_MULTIMEDIA_ADJUST_CONTRAST: 3,
    VSCP_TYPE_MULTIMEDIA_ADJUST_FOCUS: 4,
    VSCP_TYPE_MULTIMEDIA_ADJUST_TINT: 5,
    VSCP_TYPE_MULTIMEDIA_ADJUST_COLOUR_BALANCE: 6,
    VSCP_TYPE_MULTIMEDIA_ADJUST_BRIGHTNESS: 7,
    VSCP_TYPE_MULTIMEDIA_ADJUST_HUE: 8,
    VSCP_TYPE_MULTIMEDIA_ADJUST_BASS: 9,
    VSCP_TYPE_MULTIMEDIA_ADJUST_TREBLE: 10,
    VSCP_TYPE_MULTIMEDIA_ADJUST_MASTER_VOLUME: 11,
    VSCP_TYPE_MULTIMEDIA_ADJUST_FRONT_VOLUME: 12,
    VSCP_TYPE_MULTIMEDIA_ADJUST_CENTRE_VOLUME: 13,
    VSCP_TYPE_MULTIMEDIA_ADJUST_REAR_VOLUME: 14,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SIDE_VOLUME: 15,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_DISK: 20,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_TRACK: 21,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_ALBUM: 22,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_CHANNEL: 23,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_PAGE: 24,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_CHAPTER: 25,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_SCREEN_FORMAT: 26,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_INPUT_SOURCE: 27,
    VSCP_TYPE_MULTIMEDIA_ADJUST_SELECT_OUTPUT: 28,
    VSCP_TYPE_MULTIMEDIA_RECORD: 29,
    VSCP_TYPE_MULTIMEDIA_SET_RECORDING_VOLUME: 30,
    VSCP_TYPE_MULTIMEDIA_TIVO_FUNCTION: 40,
    VSCP_TYPE_MULTIMEDIA_GET_CURRENT_TITLE: 50,
    VSCP_TYPE_MULTIMEDIA_SET_POSITION: 51,
    VSCP_TYPE_MULTIMEDIA_GET_MEDIA_INFO: 52,
    VSCP_TYPE_MULTIMEDIA_REMOVE_ITEM: 53,
    VSCP_TYPE_MULTIMEDIA_REMOVE_ALL_ITEMS: 54,
    VSCP_TYPE_MULTIMEDIA_SAVE_ALBUM: 55,
    VSCP_TYPE_MULTIMEDIA_CONTROL: 60,
    VSCP_TYPE_MULTIMEDIA_CONTROL_RESPONSE: 61,

    // class 50 (0x32) -- AOL
    VSCP_TYPE_AOL_GENERAL: 0,
    VSCP_TYPE_AOL_UNPLUGGED_POWER: 1,
    VSCP_TYPE_AOL_UNPLUGGED_LAN: 2,
    VSCP_TYPE_AOL_CHASSIS_INTRUSION: 3,
    VSCP_TYPE_AOL_PROCESSOR_REMOVAL: 4,
    VSCP_TYPE_AOL_ENVIRONMENT_ERROR: 5,
    VSCP_TYPE_AOL_HIGH_TEMPERATURE: 6,
    VSCP_TYPE_AOL_FAN_SPEED: 7,
    VSCP_TYPE_AOL_VOLTAGE_FLUCTUATIONS: 8,
    VSCP_TYPE_AOL_OS_ERROR: 9,
    VSCP_TYPE_AOL_POWER_ON_ERROR: 10,
    VSCP_TYPE_AOL_SYSTEM_HUNG: 11,
    VSCP_TYPE_AOL_COMPONENT_FAILURE: 12,
    VSCP_TYPE_AOL_REBOOT_UPON_FAILURE: 13,
    VSCP_TYPE_AOL_REPAIR_OPERATING_SYSTEM: 14,
    VSCP_TYPE_AOL_UPDATE_BIOS_IMAGE: 15,
    VSCP_TYPE_AOL_UPDATE_DIAGNOSTIC_PROCEDURE: 16,

    // class 60 (0x3C) -- CLASS1.MEASUREMENT64
    // Types are the same as CLASS1.MEASUREMENT=10
    VSCP_TYPE_MEASUREMENT64_GENERAL: 0,
    VSCP_TYPE_MEASUREMENT64_COUNT: 1,
    VSCP_TYPE_MEASUREMENT64_LENGTH: 2,
    VSCP_TYPE_MEASUREMENT64_MASS: 3,
    VSCP_TYPE_MEASUREMENT64_TIME: 4,
    VSCP_TYPE_MEASUREMENT64_ELECTRIC_CURRENT: 5,
    VSCP_TYPE_MEASUREMENT64_TEMPERATURE: 6,
    VSCP_TYPE_MEASUREMENT64_AMOUNT_OF_SUBSTANCE: 7,
    VSCP_TYPE_MEASUREMENT64_INTENSITY_OF_LIGHT: 8,
    VSCP_TYPE_MEASUREMENT64_FREQUENCY: 9,
    VSCP_TYPE_MEASUREMENT64_RADIOACTIVITY: 10,
    VSCP_TYPE_MEASUREMENT64_FORCE: 11,
    VSCP_TYPE_MEASUREMENT64_PRESSURE: 12,
    VSCP_TYPE_MEASUREMENT64_ENERGY: 13,
    VSCP_TYPE_MEASUREMENT64_POWER: 14,
    VSCP_TYPE_MEASUREMENT64_ELECTRICAL_CHARGE: 15,
    VSCP_TYPE_MEASUREMENT64_ELECTRICAL_POTENTIAL: 16,
    VSCP_TYPE_MEASUREMENT64_ELECTRICAL_CAPACITANCE: 17,
    VSCP_TYPE_MEASUREMENT64_ELECTRICAL_RECISTANCE: 18,
    VSCP_TYPE_MEASUREMENT64_ELECTRICAL_CONDUCTANCE: 19,
    VSCP_TYPE_MEASUREMENT64_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP_TYPE_MEASUREMENT64_MAGNETIC_FLUX: 21,
    VSCP_TYPE_MEASUREMENT64_MAGNETIC_FLUX_DENSITY: 22,
    VSCP_TYPE_MEASUREMENT64_INDUCTANCE: 23,
    VSCP_TYPE_MEASUREMENT64_FLUX_OF_LIGHT: 24,
    VSCP_TYPE_MEASUREMENT64_ILLUMINANCE: 25,
    VSCP_TYPE_MEASUREMENT64_RADIATION_DOSE: 26,
    VSCP_TYPE_MEASUREMENT64_CATALYTIC_ACITIVITY: 27,
    VSCP_TYPE_MEASUREMENT64_VOLUME: 28,
    VSCP_TYPE_MEASUREMENT64_SOUND_INTENSITY: 29,
    VSCP_TYPE_MEASUREMENT64_ANGLE: 30,
    VSCP_TYPE_MEASUREMENT64_POSITION: 31,
    VSCP_TYPE_MEASUREMENT64_SPEED: 32,
    VSCP_TYPE_MEASUREMENT64_ACCELERATION: 33,
    VSCP_TYPE_MEASUREMENT64_TENSION: 34,
    VSCP_TYPE_MEASUREMENT64_HUMIDITY: 35,
    VSCP_TYPE_MEASUREMENT64_FLOW: 36,
    VSCP_TYPE_MEASUREMENT64_THERMAL_RESISTANCE: 37,
    VSCP_TYPE_MEASUREMENT64_REFRACTIVE_POWER: 38,
    VSCP_TYPE_MEASUREMENT64_DYNAMIC_VISCOSITY: 39,
    VSCP_TYPE_MEASUREMENT64_SOUND_IMPEDANCE: 40,
    VSCP_TYPE_MEASUREMENT64_SOUND_RESISTANCE: 41,
    VSCP_TYPE_MEASUREMENT64_ELECTRIC_ELASTANCE: 42,
    VSCP_TYPE_MEASUREMENT64_LUMINOUS_ENERGY: 43,
    VSCP_TYPE_MEASUREMENT64_LUMINANCE: 44,
    VSCP_TYPE_MEASUREMENT64_CHEMICAL_CONCENTRATION: 45,
    VSCP_TYPE_MEASUREMENT64_RESERVED: 46,
    VSCP_TYPE_MEASUREMENT64_DOSE_EQVIVALENT: 47,
    VSCP_TYPE_MEASUREMENT64_DEWPOINT: 49,
    VSCP_TYPE_MEASUREMENT64_RELATIVE_LEVEL: 50,
    VSCP_TYPE_MEASUREMENT64_ALTITUDE: 51,
    VSCP_TYPE_MEASUREMENT64_AREA: 52,
    VSCP_TYPE_MEASUREMENT64_RADIANT_INTENSITY: 53,
    VSCP_TYPE_MEASUREMENT64_RADIANCE: 54,
    VSCP_TYPE_MEASUREMENT64_IRRADIANCE: 55,
    VSCP_TYPE_MEASUREMENT64_SPECTRAL_RADIANCE: 56,
    VSCP_TYPE_MEASUREMENT64_SPECTRAL_IRRADIANCE: 57,

    // class 65 (0x41) -- CLASS1.MEASUREZONE
    // Types are the same as CLASS1.MEASUREMENT=10
    VSCP_TYPE_MEASUREZONE_GENERAL: 0,
    VSCP_TYPE_MEASUREZONE_COUNT: 1,
    VSCP_TYPE_MEASUREZONE_LENGTH: 2,
    VSCP_TYPE_MEASUREZONE_MASS: 3,
    VSCP_TYPE_MEASUREZONE_TIME: 4,
    VSCP_TYPE_MEASUREZONE_ELECTRIC_CURRENT: 5,
    VSCP_TYPE_MEASUREZONE_TEMPERATURE: 6,
    VSCP_TYPE_MEASUREZONE_AMOUNT_OF_SUBSTANCE: 7,
    VSCP_TYPE_MEASUREZONE_INTENSITY_OF_LIGHT: 8,
    VSCP_TYPE_MEASUREZONE_FREQUENCY: 9,
    VSCP_TYPE_MEASUREZONE_RADIOACTIVITY: 10,
    VSCP_TYPE_MEASUREZONE_FORCE: 11,
    VSCP_TYPE_MEASUREZONE_PRESSURE: 12,
    VSCP_TYPE_MEASUREZONE_ENERGY: 13,
    VSCP_TYPE_MEASUREZONE_POWER: 14,
    VSCP_TYPE_MEASUREZONE_ELECTRICAL_CHARGE: 15,
    VSCP_TYPE_MEASUREZONE_ELECTRICAL_POTENTIAL: 16,
    VSCP_TYPE_MEASUREZONE_ELECTRICAL_CAPACITANCE: 17,
    VSCP_TYPE_MEASUREZONE_ELECTRICAL_RECISTANCE: 18,
    VSCP_TYPE_MEASUREZONE_ELECTRICAL_CONDUCTANCE: 19,
    VSCP_TYPE_MEASUREZONE_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP_TYPE_MEASUREZONE_MAGNETIC_FLUX: 21,
    VSCP_TYPE_MEASUREZONE_MAGNETIC_FLUX_DENSITY: 22,
    VSCP_TYPE_MEASUREZONE_INDUCTANCE: 23,
    VSCP_TYPE_MEASUREZONE_FLUX_OF_LIGHT: 24,
    VSCP_TYPE_MEASUREZONE_ILLUMINANCE: 25,
    VSCP_TYPE_MEASUREZONE_RADIATION_DOSE: 26,
    VSCP_TYPE_MEASUREZONE_CATALYTIC_ACITIVITY: 27,
    VSCP_TYPE_MEASUREZONE_VOLUME: 28,
    VSCP_TYPE_MEASUREZONE_SOUND_INTENSITY: 29,
    VSCP_TYPE_MEASUREZONE_ANGLE: 30,
    VSCP_TYPE_MEASUREZONE_POSITION: 31,
    VSCP_TYPE_MEASUREZONE_SPEED: 32,
    VSCP_TYPE_MEASUREZONE_ACCELERATION: 33,
    VSCP_TYPE_MEASUREZONE_TENSION: 34,
    VSCP_TYPE_MEASUREZONE_HUMIDITY: 35,
    VSCP_TYPE_MEASUREZONE_FLOW: 36,
    VSCP_TYPE_MEASUREZONE_THERMAL_RESISTANCE: 37,
    VSCP_TYPE_MEASUREZONE_REFRACTIVE_POWER: 38,
    VSCP_TYPE_MEASUREZONE_DYNAMIC_VISCOSITY: 39,
    VSCP_TYPE_MEASUREZONE_SOUND_IMPEDANCE: 40,
    VSCP_TYPE_MEASUREZONE_SOUND_RESISTANCE: 41,
    VSCP_TYPE_MEASUREZONE_ELECTRIC_ELASTANCE: 42,
    VSCP_TYPE_MEASUREZONE_LUMINOUS_ENERGY: 43,
    VSCP_TYPE_MEASUREZONE_LUMINANCE: 44,
    VSCP_TYPE_MEASUREZONE_CHEMICAL_CONCENTRATION: 45,
    VSCP_TYPE_MEASUREZONE_RESERVED: 46,
    VSCP_TYPE_MEASUREZONE_DOSE_EQVIVALENT: 47,
    VSCP_TYPE_MEASUREZONE_DEWPOINT: 49,
    VSCP_TYPE_MEASUREZONE_RELATIVE_LEVEL: 50,
    VSCP_TYPE_MEASUREZONE_ALTITUDE: 51,
    VSCP_TYPE_MEASUREZONE_AREA: 52,
    VSCP_TYPE_MEASUREZONE_RADIANT_INTENSITY: 53,
    VSCP_TYPE_MEASUREZONE_RADIANCE: 54,
    VSCP_TYPE_MEASUREZONE_IRRADIANCE: 55,
    VSCP_TYPE_MEASUREZONE_SPECTRAL_RADIANCE: 56,
    VSCP_TYPE_MEASUREZONE_SPECTRAL_IRRADIANCE: 57,

    // class 70 (0x46) -- CLASS1.MEASUREMENT32
    // Types are the same as CLASS1.MEASUREMENT=10
    VSCP_TYPE_MEASUREMENT32_GENERAL: 0,
    VSCP_TYPE_MEASUREMENT32_COUNT: 1,
    VSCP_TYPE_MEASUREMENT32_LENGTH: 2,
    VSCP_TYPE_MEASUREMENT32_MASS: 3,
    VSCP_TYPE_MEASUREMENT32_TIME: 4,
    VSCP_TYPE_MEASUREMENT32_ELECTRIC_CURRENT: 5,
    VSCP_TYPE_MEASUREMENT32_TEMPERATURE: 6,
    VSCP_TYPE_MEASUREMENT32_AMOUNT_OF_SUBSTANCE: 7,
    VSCP_TYPE_MEASUREMENT32_INTENSITY_OF_LIGHT: 8,
    VSCP_TYPE_MEASUREMENT32_FREQUENCY: 9,
    VSCP_TYPE_MEASUREMENT32_RADIOACTIVITY: 10,
    VSCP_TYPE_MEASUREMENT32_FORCE: 11,
    VSCP_TYPE_MEASUREMENT32_PRESSURE: 12,
    VSCP_TYPE_MEASUREMENT32_ENERGY: 13,
    VSCP_TYPE_MEASUREMENT32_POWER: 14,
    VSCP_TYPE_MEASUREMENT32_ELECTRICAL_CHARGE: 15,
    VSCP_TYPE_MEASUREMENT32_ELECTRICAL_POTENTIAL: 16,
    VSCP_TYPE_MEASUREMENT32_ELECTRICAL_CAPACITANCE: 17,
    VSCP_TYPE_MEASUREMENT32_ELECTRICAL_RECISTANCE: 18,
    VSCP_TYPE_MEASUREMENT32_ELECTRICAL_CONDUCTANCE: 19,
    VSCP_TYPE_MEASUREMENT32_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP_TYPE_MEASUREMENT32_MAGNETIC_FLUX: 21,
    VSCP_TYPE_MEASUREMENT32_MAGNETIC_FLUX_DENSITY: 22,
    VSCP_TYPE_MEASUREMENT32_INDUCTANCE: 23,
    VSCP_TYPE_MEASUREMENT32_FLUX_OF_LIGHT: 24,
    VSCP_TYPE_MEASUREMENT32_ILLUMINANCE: 25,
    VSCP_TYPE_MEASUREMENT32_RADIATION_DOSE: 26,
    VSCP_TYPE_MEASUREMENT32_CATALYTIC_ACITIVITY: 27,
    VSCP_TYPE_MEASUREMENT32_VOLUME: 28,
    VSCP_TYPE_MEASUREMENT32_SOUND_INTENSITY: 29,
    VSCP_TYPE_MEASUREMENT32_ANGLE: 30,
    VSCP_TYPE_MEASUREMENT32_POSITION: 31,
    VSCP_TYPE_MEASUREMENT32_SPEED: 32,
    VSCP_TYPE_MEASUREMENT32_ACCELERATION: 33,
    VSCP_TYPE_MEASUREMENT32_TENSION: 34,
    VSCP_TYPE_MEASUREMENT32_HUMIDITY: 35,
    VSCP_TYPE_MEASUREMENT32_FLOW: 36,
    VSCP_TYPE_MEASUREMENT32_THERMAL_RESISTANCE: 37,
    VSCP_TYPE_MEASUREMENT32_REFRACTIVE_POWER: 38,
    VSCP_TYPE_MEASUREMENT32_DYNAMIC_VISCOSITY: 39,
    VSCP_TYPE_MEASUREMENT32_SOUND_IMPEDANCE: 40,
    VSCP_TYPE_MEASUREMENT32_SOUND_RESISTANCE: 41,
    VSCP_TYPE_MEASUREMENT32_ELECTRIC_ELASTANCE: 42,
    VSCP_TYPE_MEASUREMENT32_LUMINOUS_ENERGY: 43,
    VSCP_TYPE_MEASUREMENT32_LUMINANCE: 44,
    VSCP_TYPE_MEASUREMENT32_CHEMICAL_CONCENTRATION: 45,
    VSCP_TYPE_MEASUREMENT32_RESERVED: 46,
    VSCP_TYPE_MEASUREMENT32_DOSE_EQVIVALENT: 47,
    VSCP_TYPE_MEASUREMENT32_DEWPOINT: 49,
    VSCP_TYPE_MEASUREMENT32_RELATIVE_LEVEL: 50,
    VSCP_TYPE_MEASUREMENT32_ALTITUDE: 51,
    VSCP_TYPE_MEASUREMENT32_AREA: 52,
    VSCP_TYPE_MEASUREMENT32_RADIANT_INTENSITY: 53,
    VSCP_TYPE_MEASUREMENT32_RADIANCE: 54,
    VSCP_TYPE_MEASUREMENT32_IRRADIANCE: 55,
    VSCP_TYPE_MEASUREMENT32_SPECTRAL_RADIANCE: 56,
    VSCP_TYPE_MEASUREMENT32_SPECTRAL_IRRADIANCE: 57,

    // class 85 (0x55) -- CLASS1.SETVALUEZONE
    // Types are the same as CLASS1.MEASUREMENT=10
    VSCP_TYPE_SETVALUEZONE_GENERAL: 0,
    VSCP_TYPE_SETVALUEZONE_COUNT: 1,
    VSCP_TYPE_SETVALUEZONE_LENGTH: 2,
    VSCP_TYPE_SETVALUEZONE_MASS: 3,
    VSCP_TYPE_SETVALUEZONE_TIME: 4,
    VSCP_TYPE_SETVALUEZONE_ELECTRIC_CURRENT: 5,
    VSCP_TYPE_SETVALUEZONE_TEMPERATURE: 6,
    VSCP_TYPE_SETVALUEZONE_AMOUNT_OF_SUBSTANCE: 7,
    VSCP_TYPE_SETVALUEZONE_INTENSITY_OF_LIGHT: 8,
    VSCP_TYPE_SETVALUEZONE_FREQUENCY: 9,
    VSCP_TYPE_SETVALUEZONE_RADIOACTIVITY: 10,
    VSCP_TYPE_SETVALUEZONE_FORCE: 11,
    VSCP_TYPE_SETVALUEZONE_PRESSURE: 12,
    VSCP_TYPE_SETVALUEZONE_ENERGY: 13,
    VSCP_TYPE_SETVALUEZONE_POWER: 14,
    VSCP_TYPE_SETVALUEZONE_ELECTRICAL_CHARGE: 15,
    VSCP_TYPE_SETVALUEZONE_ELECTRICAL_POTENTIAL: 16,
    VSCP_TYPE_SETVALUEZONE_ELECTRICAL_CAPACITANCE: 17,
    VSCP_TYPE_SETVALUEZONE_ELECTRICAL_RECISTANCE: 18,
    VSCP_TYPE_SETVALUEZONE_ELECTRICAL_CONDUCTANCE: 19,
    VSCP_TYPE_SETVALUEZONE_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP_TYPE_SETVALUEZONE_MAGNETIC_FLUX: 21,
    VSCP_TYPE_SETVALUEZONE_MAGNETIC_FLUX_DENSITY: 22,
    VSCP_TYPE_SETVALUEZONE_INDUCTANCE: 23,
    VSCP_TYPE_SETVALUEZONE_FLUX_OF_LIGHT: 24,
    VSCP_TYPE_SETVALUEZONE_ILLUMINANCE: 25,
    VSCP_TYPE_SETVALUEZONE_RADIATION_DOSE: 26,
    VSCP_TYPE_SETVALUEZONE_CATALYTIC_ACITIVITY: 27,
    VSCP_TYPE_SETVALUEZONE_VOLUME: 28,
    VSCP_TYPE_SETVALUEZONE_SOUND_INTENSITY: 29,
    VSCP_TYPE_SETVALUEZONE_ANGLE: 30,
    VSCP_TYPE_SETVALUEZONE_POSITION: 31,
    VSCP_TYPE_SETVALUEZONE_SPEED: 32,
    VSCP_TYPE_SETVALUEZONE_ACCELERATION: 33,
    VSCP_TYPE_SETVALUEZONE_TENSION: 34,
    VSCP_TYPE_SETVALUEZONE_HUMIDITY: 35,
    VSCP_TYPE_SETVALUEZONE_FLOW: 36,
    VSCP_TYPE_SETVALUEZONE_THERMAL_RESISTANCE: 37,
    VSCP_TYPE_SETVALUEZONE_REFRACTIVE_POWER: 38,
    VSCP_TYPE_SETVALUEZONE_DYNAMIC_VISCOSITY: 39,
    VSCP_TYPE_SETVALUEZONE_SOUND_IMPEDANCE: 40,
    VSCP_TYPE_SETVALUEZONE_SOUND_RESISTANCE: 41,
    VSCP_TYPE_SETVALUEZONE_ELECTRIC_ELASTANCE: 42,
    VSCP_TYPE_SETVALUEZONE_LUMINOUS_ENERGY: 43,
    VSCP_TYPE_SETVALUEZONE_LUMINANCE: 44,
    VSCP_TYPE_SETVALUEZONE_CHEMICAL_CONCENTRATION: 45,
    VSCP_TYPE_SETVALUEZONE_RESERVED: 46,
    VSCP_TYPE_SETVALUEZONE_DOSE_EQVIVALENT: 47,
    VSCP_TYPE_SETVALUEZONE_DEWPOINT: 49,
    VSCP_TYPE_SETVALUEZONE_RELATIVE_LEVEL: 50,
    VSCP_TYPE_SETVALUEZONE_ALTITUDE: 51,
    VSCP_TYPE_SETVALUEZONE_AREA: 52,
    VSCP_TYPE_SETVALUEZONE_RADIANT_INTENSITY: 53,
    VSCP_TYPE_SETVALUEZONE_RADIANCE: 54,
    VSCP_TYPE_SETVALUEZONE_IRRADIANCE: 55,
    VSCP_TYPE_SETVALUEZONE_SPECTRAL_RADIANCE: 56,
    VSCP_TYPE_SETVALUEZONE_SPECTRAL_IRRADIANCE: 57,


    // class 90 (0x5A) -- WATHER
    VSCP_TYPE_WEATHER_GENERAL: 0,
    VSCP_TYPE_WEATHER_SEASONS_WINTER: 1,
    VSCP_TYPE_WEATHER_SEASONS_SPRING: 2,
    VSCP_TYPE_WEATHER_SEASONS_SUMMER: 3,
    VSCP_TYPE_WEATHER_SEASONS_AUTUMN: 4,
    VSCP_TYPE_WEATHER_WIND_NONE: 5,
    VSCP_TYPE_WEATHER_WIND_LOW: 6,
    VSCP_TYPE_WEATHER_WIND_MEDIUM: 7,
    VSCP_TYPE_WEATHER_WIND_HIGH: 8,
    VSCP_TYPE_WEATHER_WIND_VERY_HIGH: 9,
    VSCP_TYPE_WEATHER_AIR_FOGGY: 10,
    VSCP_TYPE_WEATHER_AIR_FREEZING: 11,
    VSCP_TYPE_WEATHER_AIR_COLD: 12,
    VSCP_TYPE_WEATHER_AIR_VERY_COLD: 13,
    VSCP_TYPE_WEATHER_AIR_NORMAL: 14,
    VSCP_TYPE_WEATHER_AIR_HOT: 15,
    VSCP_TYPE_WEATHER_AIR_VERY_HOT: 16,
    VSCP_TYPE_WEATHER_AIR_POLLUTION_LOW: 17,
    VSCP_TYPE_WEATHER_AIR_POLLUTION_MEDIUM: 18,
    VSCP_TYPE_WEATHER_AIR_POLLUTION_HIGH: 19,
    VSCP_TYPE_WEATHER_AIR_HUMID: 20,
    VSCP_TYPE_WEATHER_AIR_DRY: 21,
    VSCP_TYPE_WEATHER_SOIL_HUMID: 22,
    VSCP_TYPE_WEATHER_SOIL_DRY: 23,
    VSCP_TYPE_WEATHER_RAIN_NONE: 24,
    VSCP_TYPE_WEATHER_RAIN_LIGHT: 25,
    VSCP_TYPE_WEATHER_RAIN_HEAVY: 26,
    VSCP_TYPE_WEATHER_RAIN_VERY_HEAVY: 27,
    VSCP_TYPE_WEATHER_SUN_NONE: 28,
    VSCP_TYPE_WEATHER_SUN_LIGHT: 29,
    VSCP_TYPE_WEATHER_SUN_HEAVY: 30,
    VSCP_TYPE_WEATHER_SNOW_NONE: 31,
    VSCP_TYPE_WEATHER_SNOW_LIGHT: 32,
    VSCP_TYPE_WEATHER_SNOW_HEAVY: 33,
    VSCP_TYPE_WEATHER_DEW_POINT: 34,
    VSCP_TYPE_WEATHER_STORM: 35,
    VSCP_TYPE_WEATHER_FLOOD: 36,
    VSCP_TYPE_WEATHER_EARTHQUAKE: 37,
    VSCP_TYPE_WEATHER_NUCLEAR_DISASTER: 38,
    VSCP_TYPE_WEATHER_FIRE: 39,
    VSCP_TYPE_WEATHER_LIGHTNING: 40,
    VSCP_TYPE_WEATHER_UV_RADIATION_LOW: 41,
    VSCP_TYPE_WEATHER_UV_RADIATION_MEDIUM: 42,
    VSCP_TYPE_WEATHER_UV_RADIATION_NORMAL: 43,
    VSCP_TYPE_WEATHER_UV_RADIATION_HIGH: 44,
    VSCP_TYPE_WEATHER_UV_RADIATION_VERY_HIGH: 45,
    VSCP_TYPE_WEATHER_WARNING_LEVEL1: 46,
    VSCP_TYPE_WEATHER_WARNING_LEVEL2: 47,
    VSCP_TYPE_WEATHER_WARNING_LEVEL3: 48,
    VSCP_TYPE_WEATHER_WARNING_LEVEL4: 49,
    VSCP_TYPE_WEATHER_WARNING_LEVEL5: 50,
    VSCP_TYPE_WEATHER_ARMAGEDON: 51,

    // class 95 (0x5F) -- WATHER FORECAST
    VSCP_TYPE_WEATHER_FORECAST_GENERAL: 0,
    VSCP_TYPE_WEATHER_FORECAST_SEASONS_WINTER: 1,
    VSCP_TYPE_WEATHER_FORECAST_SEASONS_SPRING: 2,
    VSCP_TYPE_WEATHER_FORECAST_SEASONS_SUMMER: 3,
    VSCP_TYPE_WEATHER_FORECAST_SEASONS_AUTUMN: 4,
    VSCP_TYPE_WEATHER_FORECAST_WIND_NONE: 5,
    VSCP_TYPE_WEATHER_FORECAST_WIND_LOW: 6,
    VSCP_TYPE_WEATHER_FORECAST_WIND_MEDIUM: 7,
    VSCP_TYPE_WEATHER_FORECAST_WIND_HIGH: 8,
    VSCP_TYPE_WEATHER_FORECAST_WIND_VERY_HIGH: 9,
    VSCP_TYPE_WEATHER_FORECAST_AIR_FOGGY: 10,
    VSCP_TYPE_WEATHER_FORECAST_AIR_FREEZING: 11,
    VSCP_TYPE_WEATHER_FORECAST_AIR_COLD: 12,
    VSCP_TYPE_WEATHER_FORECAST_AIR_VERY_COLD: 13,
    VSCP_TYPE_WEATHER_FORECAST_AIR_NORMAL: 14,
    VSCP_TYPE_WEATHER_FORECAST_AIR_HOT: 15,
    VSCP_TYPE_WEATHER_FORECAST_AIR_VERY_HOT: 16,
    VSCP_TYPE_WEATHER_FORECAST_AIR_POLLUTION_LOW: 17,
    VSCP_TYPE_WEATHER_FORECAST_AIR_POLLUTION_MEDIUM: 18,
    VSCP_TYPE_WEATHER_FORECAST_AIR_POLLUTION_HIGH: 19,
    VSCP_TYPE_WEATHER_FORECAST_AIR_HUMID: 20,
    VSCP_TYPE_WEATHER_FORECAST_AIR_DRY: 21,
    VSCP_TYPE_WEATHER_FORECAST_SOIL_HUMID: 22,
    VSCP_TYPE_WEATHER_FORECAST_SOIL_DRY: 23,
    VSCP_TYPE_WEATHER_FORECAST_RAIN_NONE: 24,
    VSCP_TYPE_WEATHER_FORECAST_RAIN_LIGHT: 25,
    VSCP_TYPE_WEATHER_FORECAST_RAIN_HEAVY: 26,
    VSCP_TYPE_WEATHER_FORECAST_RAIN_VERY_HEAVY: 27,
    VSCP_TYPE_WEATHER_FORECAST_SUN_NONE: 28,
    VSCP_TYPE_WEATHER_FORECAST_SUN_LIGHT: 29,
    VSCP_TYPE_WEATHER_FORECAST_SUN_HEAVY: 30,
    VSCP_TYPE_WEATHER_FORECAST_SNOW_NONE: 31,
    VSCP_TYPE_WEATHER_FORECAST_SNOW_LIGHT: 32,
    VSCP_TYPE_WEATHER_FORECAST_SNOW_HEAVY: 33,
    VSCP_TYPE_WEATHER_FORECAST_DEW_POINT: 34,
    VSCP_TYPE_WEATHER_FORECAST_STORM: 35,
    VSCP_TYPE_WEATHER_FORECAST_FLOOD: 36,
    VSCP_TYPE_WEATHER_FORECAST_EARTHQUAKE: 37,
    VSCP_TYPE_WEATHER_FORECAST_NUCLEAR_DISASTER: 38,
    VSCP_TYPE_WEATHER_FORECAST_FIRE: 39,
    VSCP_TYPE_WEATHER_FORECAST_LIGHTNING: 40,
    VSCP_TYPE_WEATHER_FORECAST_UV_RADIATION_LOW: 41,
    VSCP_TYPE_WEATHER_FORECAST_UV_RADIATION_MEDIUM: 42,
    VSCP_TYPE_WEATHER_FORECAST_UV_RADIATION_NORMAL: 43,
    VSCP_TYPE_WEATHER_FORECAST_UV_RADIATION_HIGH: 44,
    VSCP_TYPE_WEATHER_FORECAST_UV_RADIATION_VERY_HIGH: 45,
    VSCP_TYPE_WEATHER_FORECAST_WARNING_LEVEL1: 46,
    VSCP_TYPE_WEATHER_FORECAST_WARNING_LEVEL2: 47,
    VSCP_TYPE_WEATHER_FORECAST_WARNING_LEVEL3: 48,
    VSCP_TYPE_WEATHER_FORECAST_WARNING_LEVEL4: 49,
    VSCP_TYPE_WEATHER_FORECAST_WARNING_LEVEL5: 50,
    VSCP_TYPE_WEATHER_FORECAST_ARMAGEDDON: 51,



    // class 100 (0x64) -- PHONE
    VSCP_TYPE_PHONE_GENERAL: 0,
    VSCP_TYPE_PHONE_INCOMING_CALL: 1,
    VSCP_TYPE_PHONE_OUTGOING_CALL: 2,
    VSCP_TYPE_PHONE_RING: 3,
    VSCP_TYPE_PHONE_ANSWERE: 4,
    VSCP_TYPE_PHONE_HANGUP: 5,
    VSCP_TYPE_PHONE_GIVEUP: 6,
    VSCP_TYPE_PHONE_TRANSFER: 7,
    VSCP_TYPE_PHONE_DATABASE_INFO: 8,

    // class 102 (0x66) -- DISPLAY
    VSCP_TYPE_DISPLAY_GENERAL: 0,
    VSCP_TYPE_DISPLAY_CLEAR_DISPLAY: 1,
    VSCP_TYPE_DISPLAY_POSITION_CURSOR: 2,
    VSCP_TYPE_DISPLAY_WRITE_DISPLAY: 3,
    VSCP_TYPE_DISPLAY_WRITE_DISPLAY_BUFFER: 4,
    VSCP_TYPE_DISPLAY_SHOW_DISPLAY_BUFFER: 5,
    VSCP_TYPE_DISPLAY_SET_DISPLAY_BUFFER_PARAM: 6,
    VSCP_TYPE_DISPLAY_SHOW_TEXT: 32,
    VSCP_TYPE_DISPLAY_SHOW_LED: 48,
    VSCP_TYPE_DISPLAY_SHOW_LED_COLOR: 49,

    // class 110 (0x6E) -- REMOTE
    VSCP_TYPE_REMOTE_GENERAL: 0,
    VSCP_TYPE_REMOTE_RC5: 1,
    VSCP_TYPE_REMOTE_SONY12: 2,
    VSCP_TYPE_REMOTE_LIRC: 32,
    VSCP_TYPE_REMOTE_VSCP: 48,

    // class 206 (0xCE) -- GPS
    VSCP_TYPE_GPS_GENERAL: 0,
    VSCP_TYPE_GPS_POSITION: 1,
    VSCP_TYPE_GPS_SATELLITES: 2,

    // class 212 (0xD4) -- WIRELESS
    VSCP_TYPE_WIRELESS_GENERAL: 0,
    VSCP_TYPE_WIRELESS_GSM_CELL: 1,

    // class 506 (0x1FA) -- DIAGNOSTIC
    VSCP_TYPE_DIAGNOSTIC_GENERAL: 0,
    VSCP_TYPE_DIAGNOSTIC_OVERVOLTAGE: 1,
    VSCP_TYPE_DIAGNOSTIC_UNDERVOLTAGE: 2,
    VSCP_TYPE_DIAGNOSTIC_VBUS_LOW: 3,
    VSCP_TYPE_DIAGNOSTIC_BATTERY_LOW: 4,
    VSCP_TYPE_DIAGNOSTIC_BATTERY_FULL: 5,
    VSCP_TYPE_DIAGNOSTIC_BATTERY_ERROR: 6,
    VSCP_TYPE_DIAGNOSTIC_BATTERY_OK: 7,
    VSCP_TYPE_DIAGNOSTIC_OVERCURRENT: 8,
    VSCP_TYPE_DIAGNOSTIC_CIRCUIT_ERROR: 9,
    VSCP_TYPE_DIAGNOSTIC_SHORT_CIRCUIT: 10,
    VSCP_TYPE_DIAGNOSTIC_OPEN_CIRCUIT: 11,
    VSCP_TYPE_DIAGNOSTIC_MOIST: 12,
    VSCP_TYPE_DIAGNOSTIC_WIRE_FAIL: 13,
    VSCP_TYPE_DIAGNOSTIC_WIRELESS_FAIL: 14,
    VSCP_TYPE_DIAGNOSTIC_IR_FAIL: 15,
    VSCP_TYPE_DIAGNOSTIC_1WIRE_FAIL: 16,
    VSCP_TYPE_DIAGNOSTIC_RS222_FAIL: 17,
    VSCP_TYPE_DIAGNOSTIC_RS232_FAIL: 18,
    VSCP_TYPE_DIAGNOSTIC_RS423_FAIL: 19,
    VSCP_TYPE_DIAGNOSTIC_RS485_FAIL: 20,
    VSCP_TYPE_DIAGNOSTIC_CAN_FAIL: 21,
    VSCP_TYPE_DIAGNOSTIC_LAN_FAIL: 22,
    VSCP_TYPE_DIAGNOSTIC_USB_FAIL: 23,
    VSCP_TYPE_DIAGNOSTIC_WIFI_FAIL: 24,
    VSCP_TYPE_DIAGNOSTIC_NFC_RFID_FAIL: 25,
    VSCP_TYPE_DIAGNOSTIC_LOW_SIGNAL: 26,
    VSCP_TYPE_DIAGNOSTIC_HIGH_SIGNAL: 27,
    VSCP_TYPE_DIAGNOSTIC_ADC_FAIL: 28,
    VSCP_TYPE_DIAGNOSTIC_ALU_FAIL: 29,
    VSCP_TYPE_DIAGNOSTIC_ASSERT: 30,
    VSCP_TYPE_DIAGNOSTIC_DAC_FAIL: 31,
    VSCP_TYPE_DIAGNOSTIC_DMA_FAIL: 32,
    VSCP_TYPE_DIAGNOSTIC_ETH_FAIL: 33,
    VSCP_TYPE_DIAGNOSTIC_EXCEPTION: 34,
    VSCP_TYPE_DIAGNOSTIC_FPU_FAIL: 35,
    VSCP_TYPE_DIAGNOSTIC_GPIO_FAIL: 36,
    VSCP_TYPE_DIAGNOSTIC_I2C_FAIL: 37,
    VSCP_TYPE_DIAGNOSTIC_I2S_FAIL: 38,
    VSCP_TYPE_DIAGNOSTIC_INVALID_CONFIG: 39,
    VSCP_TYPE_DIAGNOSTIC_MMU_FAIL: 40,
    VSCP_TYPE_DIAGNOSTIC_NMI: 41,
    VSCP_TYPE_DIAGNOSTIC_OVERHEAT: 42,
    VSCP_TYPE_DIAGNOSTIC_PLL_FAIL: 43,
    VSCP_TYPE_DIAGNOSTIC_POR_FAIL: 44,
    VSCP_TYPE_DIAGNOSTIC_PWM_FAIL: 45,
    VSCP_TYPE_DIAGNOSTIC_RAM_FAIL: 46,
    VSCP_TYPE_DIAGNOSTIC_ROM_FAIL: 47,
    VSCP_TYPE_DIAGNOSTIC_SPI_FAIL: 48,
    VSCP_TYPE_DIAGNOSTIC_STACK_FAIL: 49,
    VSCP_TYPE_DIAGNOSTIC_LIN_FAIL: 50,
    VSCP_TYPE_DIAGNOSTIC_UART_FAIL: 51,
    VSCP_TYPE_DIAGNOSTIC_UNHANDLED_INT: 52,
    VSCP_TYPE_DIAGNOSTIC_MEMORY_FAIL: 53,
    VSCP_TYPE_DIAGNOSTIC_VARIABLE_RANGE: 54,
    VSCP_TYPE_DIAGNOSTIC_WDT: 55,
    VSCP_TYPE_DIAGNOSTIC_EEPROM_FAIL: 56,
    VSCP_TYPE_DIAGNOSTIC_ENCRYPTION_FAIL: 57,
    VSCP_TYPE_DIAGNOSTIC_BAD_USER_INPUT: 58,
    VSCP_TYPE_DIAGNOSTIC_DECRYPTION_FAIL: 59,
    VSCP_TYPE_DIAGNOSTIC_NOISE: 60,
    VSCP_TYPE_DIAGNOSTIC_BOOTLOADER_FAIL: 61,
    VSCP_TYPE_DIAGNOSTIC_PROGRAMFLOW_FAIL: 62,
    VSCP_TYPE_DIAGNOSTIC_RTC_FAIL: 63,
    VSCP_TYPE_DIAGNOSTIC_SYSTEM_TEST_FAIL: 64,
    VSCP_TYPE_DIAGNOSTIC_SENSOR_FAIL: 65,
    VSCP_TYPE_DIAGNOSTIC_SAFESTATE: 66,
    VSCP_TYPE_DIAGNOSTIC_SIGNAL_IMPLAUSIBLE: 67,
    VSCP_TYPE_DIAGNOSTIC_STORAGE_FAIL: 68,
    VSCP_TYPE_DIAGNOSTIC_SELFTEST_FAIL: 69,
    VSCP_TYPE_DIAGNOSTIC_ESD_EMC_EMI: 70,
    VSCP_TYPE_DIAGNOSTIC_TIMEOUT: 71,
    VSCP_TYPE_DIAGNOSTIC_LCD_FAIL: 72,
    VSCP_TYPE_DIAGNOSTIC_TOUCHPANEL_FAIL: 73,
    VSCP_TYPE_DIAGNOSTIC_NOLOAD: 74,
    VSCP_TYPE_DIAGNOSTIC_COOLING_FAIL: 75,
    VSCP_TYPE_DIAGNOSTIC_HEATING_FAIL: 76,
    VSCP_TYPE_DIAGNOSTIC_TX_FAIL: 77,
    VSCP_TYPE_DIAGNOSTIC_RX_FAIL: 78,
    // 507 reserved for diagnostics

    // class 508 (0x1FC) -- ERROR
    VSCP_TYPE_ERROR_SUCCESS: 0,
    VSCP_TYPE_ERROR_ERROR: 1,
    // 2-6 reserved
    VSCP_TYPE_ERROR_CHANNEL: 7,
    VSCP_TYPE_ERROR_FIFO_EMPTY: 8,
    VSCP_TYPE_ERROR_FIFO_FULL: 9,
    VSCP_TYPE_ERROR_FIFO_SIZE: 10,
    VSCP_TYPE_ERROR_FIFO_WAIT: 11,
    VSCP_TYPE_ERROR_GENERIC: 12,
    VSCP_TYPE_ERROR_HARDWARE: 13,
    VSCP_TYPE_ERROR_INIT_FAIL: 14,
    VSCP_TYPE_ERROR_INIT_MISSING: 15,
    VSCP_TYPE_ERROR_INIT_READY: 16,
    VSCP_TYPE_ERROR_NOT_SUPPORTED: 17,
    VSCP_TYPE_ERROR_OVERRUN: 18,
    VSCP_TYPE_ERROR_RCV_EMPTY: 19,
    VSCP_TYPE_ERROR_REGISTER: 20,
    VSCP_TYPE_ERROR_TRM_FULL: 21,
    // 22-27 reserved
    VSCP_TYPE_ERROR_LIBRARY: 28,
    VSCP_TYPE_ERROR_PROCADDRESS: 29,
    VSCP_TYPE_ERROR_ONLY_ONE_INSTANCE: 30,
    VSCP_TYPE_ERROR_SUB_DRIVER: 31,
    VSCP_TYPE_ERROR_TIMEOUT: 32,
    VSCP_TYPE_ERROR_NOT_OPEN: 33,
    VSCP_TYPE_ERROR_PARAMETER: 34,
    VSCP_TYPE_ERROR_MEMORY: 35,
    VSCP_TYPE_ERROR_INTERNAL: 36,
    VSCP_TYPE_ERROR_COMMUNICATION: 37,
    VSCP_TYPE_ERROR_USER: 38,
    VSCP_TYPE_ERROR_PASSWORD: 39,
    VSCP_TYPE_ERROR_CONNECTION: 40,
    VSCP_TYPE_ERROR_INVALID_HANDLE: 41,
    VSCP_TYPE_ERROR_OPERATION_FAILED: 42,

    // class 509 (0x1FD) -- LOG
    VSCP_TYPE_LOG_GENERAL: 0,
    VSCP_TYPE_LOG_MESSAGE: 1,
    VSCP_TYPE_LOG_START: 2,
    VSCP_TYPE_LOG_STOP: 3,
    VSCP_TYPE_LOG_LEVEL: 4,

    // class 510 (0x1FE) -- LABORATORY
    VSCP_TYPE_LABORATORY_GENERAL: 0,

    // class 511 (0x1FF) -- LOCAL
    VSCP_TYPE_LOCAL_GENERAL: 0,

    ///////////////////////////////////////////////////////////////////////////////
    //              Level II
    ///////////////////////////////////////////////////////////////////////////////

    // Level II Protocol functionality Class=1024 (0x400)
    VSCP2_TYPE_PROTOCOL_GENERAL: 0,
    VSCP2_TYPE_PROTOCOL_READ_REGISTER: 1,
    VSCP2_TYPE_PROTOCOL_WRITE_REGISTER: 2,
    VSCP2_TYPE_PROTOCOL_READ_WRITE_RESPONSE: 3,
    VSCP2_TYPE_PROTOCOL_HIGH_END_SERVER_CAPS: 20,

    // Level II Control functionality Class=1025 (0x401)
    VSCP2_TYPE_CONTROL_GENERAL: 0,

    // Level II Information functionality Class=1026 (0x402)
    VSCP2_TYPE_INFORMATION_GENERAL: 0,
    VSCP2_TYPE_INFORMATION_TOKEN_ACTIVITY: 1,
    VSCP2_TYPE_INFORMATION_HEART_BEAT: 2,

    // Level II Text to speech functionality Class=1028 (0x404)
    VSCP2_TYPE_TEXT2SPEECH_GENERAL: 0,
    VSCP2_TYPE_TEXT2SPEECH_TALK: 1,

    // Level II Custom functionality Class=1029 (0x405)
    VSCP2_TYPE_CUSTOM_GENERAL: 0,

    // Level II Display functionality Class=1030 (0x406)
    VSCP2_TYPE_DISPLAY_GENERAL: 0,

    // Level II Measurement String Class=1040 (0x410)
    VSCP2_TYPE_MEASUREMENT_STR_GENERAL: 0,
    VSCP2_TYPE_MEASUREMENT_STR_COUNT: 1,
    VSCP2_TYPE_MEASUREMENT_STR_LENGTH: 2,
    VSCP2_TYPE_MEASUREMENT_STR_MASS: 3,
    VSCP2_TYPE_MEASUREMENT_STR_TIME: 4,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRIC_CURRENT: 5,
    VSCP2_TYPE_MEASUREMENT_STR_TEMPERATURE: 6,
    VSCP2_TYPE_MEASUREMENT_STR_AMOUNT_OF_SUBSTANCE: 7,
    VSCP2_TYPE_MEASUREMENT_STR_INTENSITY_OF_LIGHT: 8,
    VSCP2_TYPE_MEASUREMENT_STR_FREQUENCY: 9,
    VSCP2_TYPE_MEASUREMENT_STR_RADIOACTIVITY: 10,
    VSCP2_TYPE_MEASUREMENT_STR_FORCE: 11,
    VSCP2_TYPE_MEASUREMENT_STR_PRESSURE: 12,
    VSCP2_TYPE_MEASUREMENT_STR_ENERGY: 13,
    VSCP2_TYPE_MEASUREMENT_STR_POWER: 14,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRICAL_CHARGE: 15,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRICAL_POTENTIAL: 16,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRICAL_CAPACITANCE: 17,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRICAL_RECISTANCE: 18,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRICAL_CONDUCTANCE: 19,
    VSCP2_TYPE_MEASUREMENT_STR_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP2_TYPE_MEASUREMENT_STR_MAGNETIC_FLUX: 21,
    VSCP2_TYPE_MEASUREMENT_STR_MAGNETIC_FLUX_DENSITY: 22,
    VSCP2_TYPE_MEASUREMENT_STR_INDUCTANCE: 23,
    VSCP2_TYPE_MEASUREMENT_STR_FLUX_OF_LIGHT: 24,
    VSCP2_TYPE_MEASUREMENT_STR_ILLUMINANCE: 25,
    VSCP2_TYPE_MEASUREMENT_STR_RADIATION_DOSE: 26,
    VSCP2_TYPE_MEASUREMENT_STR_CATALYTIC_ACITIVITY: 27,
    VSCP2_TYPE_MEASUREMENT_STR_VOLUME: 28,
    VSCP2_TYPE_MEASUREMENT_STR_SOUND_INTENSITY: 29,
    VSCP2_TYPE_MEASUREMENT_STR_ANGLE: 30,
    VSCP2_TYPE_MEASUREMENT_STR_POSITION: 31,
    VSCP2_TYPE_MEASUREMENT_STR_SPEED: 32,
    VSCP2_TYPE_MEASUREMENT_STR_ACCELERATION: 33,
    VSCP2_TYPE_MEASUREMENT_STR_TENSION: 34,
    VSCP2_TYPE_MEASUREMENT_STR_HUMIDITY: 35,
    VSCP2_TYPE_MEASUREMENT_STR_FLOW: 36,
    VSCP2_TYPE_MEASUREMENT_STR_THERMAL_RESISTANCE: 37,
    VSCP2_TYPE_MEASUREMENT_STR_REFRACTIVE_POWER: 38,
    VSCP2_TYPE_MEASUREMENT_STR_DYNAMIC_VISCOSITY: 39,
    VSCP2_TYPE_MEASUREMENT_STR_SOUND_IMPEDANCE: 40,
    VSCP2_TYPE_MEASUREMENT_STR_SOUND_RESISTANCE: 41,
    VSCP2_TYPE_MEASUREMENT_STR_ELECTRIC_ELASTANCE: 42,
    VSCP2_TYPE_MEASUREMENT_STR_LUMINOUS_ENERGY: 43,
    VSCP2_TYPE_MEASUREMENT_STR_LUMINANCE: 44,
    VSCP2_TYPE_MEASUREMENT_STR_CHEMICAL_CONCENTRATION: 45,
    VSCP2_TYPE_MEASUREMENT_STR_RESERVED: 46,
    VSCP2_TYPE_MEASUREMENT_STR_DOSE_EQVIVALENT: 47,
    VSCP2_TYPE_MEASUREMENT_STR_DEWPOINT: 49,
    VSCP2_TYPE_MEASUREMENT_STR_RELATIVE_LEVEL: 50,
    VSCP2_TYPE_MEASUREMENT_STR_ALTITUDE: 51,
    VSCP2_TYPE_MEASUREMENT_STR_AREA: 52,
    VSCP2_TYPE_MEASUREMENT_STR_RADIANT_INTENSITY: 53,
    VSCP2_TYPE_MEASUREMENT_STR_RADIANCE: 54,
    VSCP2_TYPE_MEASUREMENT_STR_IRRADIANCE: 55,
    VSCP2_TYPE_MEASUREMENT_STR_SPECTRAL_RADIANCE: 56,
    VSCP2_TYPE_MEASUREMENT_STR_SPECTRAL_IRRADIANCE: 57,

    // Level II Measurement String Class=1060 (0x424)
    VSCP2_TYPE_MEASUREMENT_FLOAT_GENERAL: 0,
    VSCP2_TYPE_MEASUREMENT_FLOAT_COUNT: 1,
    VSCP2_TYPE_MEASUREMENT_FLOAT_LENGTH: 2,
    VSCP2_TYPE_MEASUREMENT_FLOAT_MASS: 3,
    VSCP2_TYPE_MEASUREMENT_FLOAT_TIME: 4,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRIC_CURRENT: 5,
    VSCP2_TYPE_MEASUREMENT_FLOAT_TEMPERATURE: 6,
    VSCP2_TYPE_MEASUREMENT_FLOAT_AMOUNT_OF_SUBSTANCE: 7,
    VSCP2_TYPE_MEASUREMENT_FLOAT_INTENSITY_OF_LIGHT: 8,
    VSCP2_TYPE_MEASUREMENT_FLOAT_FREQUENCY: 9,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RADIOACTIVITY: 10,
    VSCP2_TYPE_MEASUREMENT_FLOAT_FORCE: 11,
    VSCP2_TYPE_MEASUREMENT_FLOAT_PRESSURE: 12,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ENERGY: 13,
    VSCP2_TYPE_MEASUREMENT_FLOAT_POWER: 14,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRICAL_CHARGE: 15,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRICAL_POTENTIAL: 16,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRICAL_CAPACITANCE: 17,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRICAL_RECISTANCE: 18,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRICAL_CONDUCTANCE: 19,
    VSCP2_TYPE_MEASUREMENT_FLOAT_MAGNETIC_FIELD_STRENGTH: 20,
    VSCP2_TYPE_MEASUREMENT_FLOAT_MAGNETIC_FLUX: 21,
    VSCP2_TYPE_MEASUREMENT_FLOAT_MAGNETIC_FLUX_DENSITY: 22,
    VSCP2_TYPE_MEASUREMENT_FLOAT_INDUCTANCE: 23,
    VSCP2_TYPE_MEASUREMENT_FLOAT_FLUX_OF_LIGHT: 24,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ILLUMINANCE: 25,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RADIATION_DOSE: 26,
    VSCP2_TYPE_MEASUREMENT_FLOAT_CATALYTIC_ACITIVITY: 27,
    VSCP2_TYPE_MEASUREMENT_FLOAT_VOLUME: 28,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SOUND_INTENSITY: 29,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ANGLE: 30,
    VSCP2_TYPE_MEASUREMENT_FLOAT_POSITION: 31,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SPEED: 32,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ACCELERATION: 33,
    VSCP2_TYPE_MEASUREMENT_FLOAT_TENSION: 34,
    VSCP2_TYPE_MEASUREMENT_FLOAT_HUMIDITY: 35,
    VSCP2_TYPE_MEASUREMENT_FLOAT_FLOW: 36,
    VSCP2_TYPE_MEASUREMENT_FLOAT_THERMAL_RESISTANCE: 37,
    VSCP2_TYPE_MEASUREMENT_FLOAT_REFRACTIVE_POWER: 38,
    VSCP2_TYPE_MEASUREMENT_FLOAT_DYNAMIC_VISCOSITY: 39,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SOUND_IMPEDANCE: 40,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SOUND_RESISTANCE: 41,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ELECTRIC_ELASTANCE: 42,
    VSCP2_TYPE_MEASUREMENT_FLOAT_LUMINOUS_ENERGY: 43,
    VSCP2_TYPE_MEASUREMENT_FLOAT_LUMINANCE: 44,
    VSCP2_TYPE_MEASUREMENT_FLOAT_CHEMICAL_CONCENTRATION: 45,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RESERVED: 46,
    VSCP2_TYPE_MEASUREMENT_FLOAT_DOSE_EQVIVALENT: 47,
    VSCP2_TYPE_MEASUREMENT_FLOAT_DEWPOINT: 49,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RELATIVE_LEVEL: 50,
    VSCP2_TYPE_MEASUREMENT_FLOAT_ALTITUDE: 51,
    VSCP2_TYPE_MEASUREMENT_FLOAT_AREA: 52,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RADIANT_INTENSITY: 53,
    VSCP2_TYPE_MEASUREMENT_FLOAT_RADIANCE: 54,
    VSCP2_TYPE_MEASUREMENT_FLOAT_IRRADIANCE: 55,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SPECTRAL_RADIANCE: 56,
    VSCP2_TYPE_MEASUREMENT_FLOAT_SPECTRAL_IRRADIANCE: 57,

    // Level II VSCPD daemon functionality Class=65535 (0xFFFF)
    VSCP2_TYPE_VSCPD_GENERAL: 0,
    VSCP2_TYPE_VSCPD_LOOP: 1,
    VSCP2_TYPE_VSCPD_PAUSE: 3,
    VSCP2_TYPE_VSCPD_ACTIVATE: 4,
    VSCP2_TYPE_VSCPD_SECOND: 5,
    VSCP2_TYPE_VSCPD_MINUTE: 6,
    VSCP2_TYPE_VSCPD_HOUR: 7,
    VSCP2_TYPE_VSCPD_NOON: 8,
    VSCP2_TYPE_VSCPD_MIDNIGHT: 9,
    VSCP2_TYPE_VSCPD_WEEK: 11,
    VSCP2_TYPE_VSCPD_MONTH: 12,
    VSCP2_TYPE_VSCPD_QUARTER: 13,
    VSCP2_TYPE_VSCPD_YEAR: 14,
    VSCP2_TYPE_VSCPD_RANDOM_MINUTE: 15,
    VSCP2_TYPE_VSCPD_RANDOM_HOUR: 16,
    VSCP2_TYPE_VSCPD_RANDOM_DAY: 17,
    VSCP2_TYPE_VSCPD_RANDOM_WEEK: 18,
    VSCP2_TYPE_VSCPD_RANDOM_MONTH: 19,
    VSCP2_TYPE_VSCPD_RANDOM_YEAR: 20,
    VSCP2_TYPE_VSCPD_DUSK: 21,
    VSCP2_TYPE_VSCPD_DAWN: 22,
    VSCP2_TYPE_VSCPD_STARTING_UP: 23,
    VSCP2_TYPE_VSCPD_SHUTTING_DOWN: 24,
    VSCP2_TYPE_VSCPD_TIMER_STARTED: 25,
    VSCP2_TYPE_VSCPD_TIMER_PAUSED: 26,
    VSCP2_TYPE_VSCPD_TIMER_RESUMED: 27,
    VSCP2_TYPE_VSCPD_TIMER_STOPPED: 28,
    VSCP2_TYPE_VSCPD_TIMER_ELLAPSED: 29,
    VSCP2_TYPE_VSCPD_NEW_CALCULATION: 30
};

/** VSCP class priorities
 * @enum {number}
 * @const
 */
vscp.constants.priorities = {
    PRIORITY_0_HIGH: 0,
    PRIORITY_1: 1,
    PRIORITY_2: 2,
    PRIORITY_3_NORMAL: 3,
    PRIORITY_4: 4,
    PRIORITY_5: 5,
    PRIORITY_6: 6,
    PRIORITY_7_LOW: 7
};

/** VSCP variable types
 * @enum {number}
 * @const
 */
vscp.constants.varTypes = {
    UNASSIGNED: 0,          // Unassigned variable
    STRING: 1,              // String value
    BOOLEAN: 2,             // Boolean value (true, false, 0 or 1)
    INTEGER: 3,             // Integer value
    LONG: 4,                // Long value
    DOUBLE: 5,              // Double value
    MEASUREMENT: 6,         // String representation of the measurement.
    EVENT: 7,               // VSCP event head, class, type, obId, timestamp, GUID, data 1, data 2, data ...
    GUID: 8,                // Standard GUID string format: FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF:FF
    EVENT_DATA: 9,          // Comma separated list with decimal values. 1,2,3,4,5,6,7,8, ...
    EVENT_CLASS: 10,        // Integer value for VSCP class
    EVENT_TYPE: 11,         // Integer value for VSCP type
    EVENT_TIMESTAMP: 12,    // Time when event was received in ms
    DATE_TIME: 13           // Date + Time in ISO format 2008-11-07 20:10.00
};

/** VSCP variable type names
 * @type {string[]}
 * @const
 */
vscp.constants.varTypeNames = [
    "Unassigned",
    "String",
    "Boolean",
    "Integer",
    "Long",
    "Double",
    "Measurement",
    "Event",
    "GUID",
    "Event data",
    "Event class",
    "Event type",
    "Event timestamp",
    "Date and Time"
];

/* ---------------------------------------------------------------------- */

/**
 * VSCP event.
 * @class
 *
 * @param {object} options                              - Options
 * @param {number} options.vscpHead                     - Event head
 * @param {number} options.vscpPriority                 - Priority
 * @param {boolean} options.vscpHardCoded               - Hard coded node id
 * @param {boolean} options.vscpCalcCRC                 - Calculate CRC
 * @param {boolean} options.vscpIsCANMessage            - Is CAN message or not
 * @param {boolean} options.vscpIsExtendedCANMessage    - Is extended CAN message or not
 * @param {boolean} options.vscpIsRemoteFrame           - Is a CAN remote frame or not
 * @param {number} options.vscpClass                    - VSCP class
 * @param {number} options.vscpType                     - VSCP type
 * @param {number} options.vscpObId                     - Object id
 * @param {number} options.vscpTimeStamp                - Timestamp
 * @param {string} options.vscpGuid                     - GUID string
 * @param {(number[]|string)} options.vscpData          - Event data
 */
vscp.Event = function ( options ) {

    /** VSCP event head
     * @member {number}
     */
    this.vscpHead       = 0;

    /** VSCP class
     * @member {number}
     */
    this.vscpClass      = 0;

    /** VSCP type
     * @member {number}
     */
    this.vscpType       = 0;

    /** VSCP object id used by driver for channel info and etc.
     * @member {number}
     */
    this.vscpObId       = 0;

    /** Relative timestamp for package in us
     * @member {number}
     */
    this.vscpTimeStamp  = 0;

    /** Node global unique id LSB(15) -> MSB(0)
     * @member {string}
     */
    this.vscpGuid       = "-";

    /** Data array or string
     * @member {(number[]|string)}
     */
    this.vscpData       = [];

    if ( "undefined" !== typeof options ) {
        if ( "number" === typeof options.vscpHead ) {
            this.vscpHead = options.vscpHead;
        }
        if ( "number" === typeof options.vscpPriority ) {
            if ( ( 0 <= options.vscpPriority ) && ( 7 >= options.vscpPriority ) ) {
                this.vscpHead &= 0x1f;
                this.vscpHead |= options.vscpPriority << 5;
            }
        }
        if ( "boolean" === typeof options.vscpHardCoded ) {
            if ( false === options.vscpHardCoded ) {
                this.vscpHead &= 0xef;
            }
            else {
                this.vscpHead |= 0x10;
            }
        }
        if ( "boolean" === typeof options.vscpCalcCRC ) {
            if ( false === options.vscpCalcCRC ) {
                this.vscpHead &= 0xf7;
            }
            else {
                this.vscpHead |= 0x08;
            }
        }
        if ( "boolean" === typeof options.vscpIsCANMessage ) {
            if ( false === options.vscpIsCANMessage ) {
                this.vscpHead &= 0xfb;
            }
            else {
                this.vscpHead |= 0x04;
            }
        }
        if ( "boolean" === typeof options.vscpIsExtendedCANMessage ) {
            if ( false === options.vscpIsExtendedCANMessage ) {
                this.vscpHead &= 0xfd;
            }
            else {
                this.vscpHead |= 0x02;
            }
        }
        if ( "boolean" === typeof options.vscpIsRemoteFrame ) {
            if ( false === options.vscpIsRemoteFrame ) {
                this.vscpHead &= 0xfe;
            }
            else {
                this.vscpHead |= 0x01;
            }
        }
        if ( "number" === typeof options.vscpClass ) {
            this.vscpClass = options.vscpClass;
        }
        if ( "number" === typeof options.vscpType ) {
            this.vscpType = options.vscpType;
        }
        if ( "number" === typeof options.vscpObId ) {
            this.vscpObId = options.vscpObId;
        }
        if ( "number" === typeof options.vscpTimeStamp ) {
            this.vscpTimeStamp = options.vscpTimeStamp;
        }
        if ( "string" === typeof options.vscpGuid ) {
            this.vscpGuid = options.vscpGuid;
        }
        if ( ( "string" === typeof options.vscpData ) || ( options.vscpData instanceof Array ) ) {
            this.vscpData = options.vscpData;
        }
    }
};

/**
 * Is GUID a IP v6 address or not?
 *
 * @return {boolean} If the GUID is a IP v6 address, it will return true, otherwise false.
 */
vscp.Event.prototype.isIPV6Addr = function() {
    var result = false;

    if ( 0 < ( this.vscpHead & 0x8000 ) ) {
        result = true;
    }

    return result;
};

/**
 * Get the VSCP event priority.
 *
 * @return {number} Priority of the event.
 */
vscp.Event.prototype.getPriority = function() {
    return ( this.vscpHead >> 5 ) & 0x0007;
};

/**
 * Is the node id of the event sender hard coded or not?
 *
 * @return {boolean} If the node id is hard coded, it will return true, otherwise false.
 */
vscp.Event.prototype.isHardCodedAddr = function() {
    var result = false;

    if ( 0 < ( this.vscpHead & 0x0010 ) ) {
        result = true;
    }

    return result;
};

/* ---------------------------------------------------------------------- */

/**
 * Utility functions
 * @namespace vscp.utility
 */
vscp._createNS( "vscp.utility" );

/**
 * Utility function which returns the current time in the following format: hh:mm:ss.us
 *
 * @return {string} Current time in the format hh:mm:ss.us
 */
vscp.utility.getTime = function() {

    var now = new Date();

    var paddingHead = function( num, size ) {
        var str = num + "";

        while( str.length < size ) {
            str = "0" + str;
        }

        return str;
    };

    var paddingTail = function( num, size ) {
        var str = num + "";

        while( str.length < size ) {
            str = str + "0";
        }

        return str;
    };

    return "" + paddingHead( now.getHours(), 2 ) + ":" + paddingHead( now.getMinutes(), 2 ) + ":" + paddingHead( now.getSeconds(), 2 ) + "." + paddingTail( now.getMilliseconds(), 3 );
};

/**
 * Calculates the VSCP server websocket authentication hash.
 *
 * @param {string} userName - User name
 * @param {string} password - Password
 * @param {string} sid      - Session id
 *
 * @return {string} Authentication hash
 */
vscp.utility.getWebSocketAuthHash = function( userName, password, sid ) {

    return hex_md5( userName + ":" + password + ":" + sid );
};

/**
 * Converts a GUID number array to a GUID string.
 *
 * @param {number[]} guid - GUID number array
 * @return {string} GUID string, e.g. 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
 */
vscp.utility.guidToStr = function( guid ) {

    var guidStr     = "";
    var index       = 0;
    var hexValue    = "";

    for( index = 0; index < guid.length; ++index ) {
        hexValue = guid[ index ].toString( 16 );
        if ( 2 > hexValue.length ) {
            hexValue = "0" + hexValue;
        }

        guidStr += hexValue;

        if ( index < ( guid.length - 1 ) ) {
            guidStr += ":";
        }
    }

    return guidStr;
};

/**
 * Converts a GUID string to a GUID number array.
 *
 * @param {string} guid - GUID string, e.g. 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
 * @return {number[]} GUID number array
 */
vscp.utility.strToGuid = function( str ) {

    var guid    = [];
    var items   = [];
    var index   = 0;

    if ( "undefined" === typeof str ) {
        return guid;
    }

    if ( "string" !== typeof str ) {
        return guid;
    }

    items = str.split( ":" );

    if ( 16 !== items.length ) {
        return guid;
    }

    for( index = 0; index < items.length; ++index) {
        guid.push( parseInt( items[ index ], 16 ) );
    }

    return guid;
};

/**
 * Get node id from a node GUID string.
 *
 * @param {string} guid - GUID string, e.g. 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
 * @return {number} Node id
 */
vscp.utility.getNodeId = function( guid ) {

    if ( "undefined" === typeof guid ) {
        return 0;
    }

    if ( "string" !== typeof guid ) {
        return 0;
    }

    return parseInt( guid.split( ":" )[ 15 ], 16 );
};

/* ---------------------------------------------------------------------- */

/**
 * VSCP websocket, used for connection establishment to a VSCP server.
 * @class
 */
vscp.Connection = function() {

    /** States of the VSCP websocket
     * @enum {number}
     */
    this.states = {
        /** Not connected */
        DISCONNECTED: 0,
        /** Standard websocket connection established */
        CONNECTED: 1,
        /** Authentication with VSCP server successful */
        AUTHENTICATED: 2
    };

    /** Websocket
     * @member {object}
     */
    this.socket = null;

    /** User name used for connection establishment
     * @member {string}
     */
    this.userName = "";

    /** Password hash used for connection establishment
     * @member {string}
     */
    this.passwordHash = "";

    /** Callback called on any connection error
     * @member {function}
     */
    this.onConnError = null;

    /** Callback called on any received VSCP response message
     * @member {function}
     */
    this.onMessage = null;

    /** Callbacks called on any received VSCP event message
     * @member {function[]}
     */
    this.onEvent = [];

    /** Callback called on any received variable (see LISTVAR command)
     * @member {function}
     */
    this.onVariable = null;

    /** Callback called on any received table row (see GT command)
     * @member {function}
     */
    this.onTableRow = null;

    /** VSCP websocket is not connected right now
     * @member {number}
     */
    this.state = this.states.DISCONNECTED;

    /** VSCP server command
     * @class
     * @param {string} command      - Server command string
     * @param {function} onSuccess  - Function which is called on successful operation
     * @param {function} onerror    - Function which is called on failed operation
     */
    var Command = function( command, onSuccess, onError ) {
        /** Server command string
         * @member {string}
         */
        this.command = command;
        /** Function which is called on successful operation
         * @member {function}
         */
        this.onSuccess = onSuccess;
        /** Function which is called on failed operation
         * @member {function}
         */
        this.onError = onError;
    };

    /** Queue contains all pending VSCP server commands
     * @member {Command[]}
     */
    var cmdQueue = [];

    /** Get the index of a command in the queue.
     *
     * @param {string} command - Server command string
     *
     * @return {number} Index of command in the queue. If index is < 0, the command was not found.
     */
    var getPendingCommandIndex = function( command ) {
        var index = 0;

        for( index = 0; index < cmdQueue.length; ++index ) {
            if ( command === cmdQueue[ index ].command ) {
                break;
            }
        }

        if ( cmdQueue.length === index ) {
            index = -1;
        }

        return index;
    };

    /** Get command from queue with pending commands.
     *
     * @param {string} command - Server command string
     *
     * @return {Command} Command object
     */
    this.getPendingCommand = function( command ) {

        var index = getPendingCommandIndex( command );
        var cmd = null;

        if ( 0 <= index ) {
            cmd = cmdQueue[ index ];
            cmdQueue.splice( index, 1 );

            return cmd;
        }

        return null;
    };

    /**
     * Send command to VSCP server.
     *
     * @param {object} options              - Options
     * @param {string} options.command      - Command string
     * @param {string} options.data         - Data string
     * @param {boolean} options.simulate    - Simulate the command (true/false)
     * @param {function} options.onSuccess  - Callback on success
     * @param {function} options.onError    - Callback on error
     */
    this._sendCommand = function( options ) {

        var cmdObj      = null;
        var cmdStr      = "C;";
        var cmdData     = "";
        var simulate    = false;
        var onSuccess   = null;
        var onError     = null;

        if ( "undefined" === typeof options ) {
            console.error( vscp.utility.getTime() + " Options are missing." );
            return;
        }

        if ( "string" !== typeof options.command ) {
            console.error( vscp.utility.getTime() + " Command is missing." );
            return;
        }
        else if ( 0 === options.command ) {
            console.error( vscp.utility.getTime() + " Command is empty." );
            return;
        }

        if ( "string" === typeof options.data ) {
            cmdData = options.data;
        }

        if ( "boolean" === typeof options.simulate ) {
            simulate = options.simulate;
        }

        if ( "function" === typeof options.onSuccess ) {
            onSuccess = options.onSuccess;
        }

        if ( "function" === typeof options.onError ) {
            onError = options.onError;
        }

        /* Put command to queue with pending commands */
        cmdObj = new Command( options.command, onSuccess, onError );
        cmdQueue.push( cmdObj );

        if ( false === simulate ) {

            /* Build command string */
            cmdStr += options.command;

            if ( 0 < cmdData.length ) {
                cmdStr += ";" + cmdData;
            }

            /* Send command via websocket to the VSCP server */
            console.debug( vscp.utility.getTime() + " Cmd: " + cmdStr );
            this.socket.send( cmdStr );
        }
    };

    /**
     * Send event to VSCP server.
     *
     * @param {object} options              - Options
     * @param {string} options.data         - Data string
     * @param {function} options.onSuccess  - Callback on success
     * @param {function} options.onError    - Callback on error
     */
    this._sendEvent = function( options ) {

        var cmdObj      = null;
        var cmdStr      = "E;";
        var onSuccess   = null;
        var onError     = null;

        if ( "undefined" === typeof options ) {
            console.error( vscp.utility.getTime() + " Options are missing." );
            return;
        }

        if ( "string" !== typeof options.data ) {
            console.error( vscp.utility.getTime() + " Command data is missing." );
            return;
        }

        if ( "function" === typeof options.onSuccess ) {
            onSuccess = options.onSuccess;
        }

        if ( "function" === typeof options.onError ) {
            onError = options.onError;
        }

        /* Put command to queue with pending commands */
        cmdObj = new Command( "EVENT", onSuccess, onError );
        cmdQueue.push( cmdObj );

        /* Build command string */
        cmdStr += options.data;

        /* Send command via websocket to the VSCP server */
        console.debug( vscp.utility.getTime() + " Cmd: " + cmdStr );
        this.socket.send( cmdStr );
    };

    /**
     * Signal success of the current asynchronous operation.
     *
     * @param {string} command  - Server command string
     * @param {object} [obj]    - Options for on success callback
     */
    this.signalSuccess = function( command, obj ) {

        var cmd = this.getPendingCommand( command );

        if ( null !== cmd ) {

            if ( ( "function" === typeof cmd.onSuccess ) && ( null !== cmd.onSuccess ) ) {

                if ( "undefined" === typeof obj ) {
                    cmd.onSuccess( this );
                }
                else {
                    cmd.onSuccess( this, obj );
                }
            }
        }
    };

    /**
     * Signal failed of the current asynchronous operation.
     *
     * @param {string} command  - Server command string
     * @param {object} [obj]    - Options for on error callback
     */
    this.signalError = function( command, obj ) {

        var cmd = this.getPendingCommand( command );

        if ( null !== cmd ) {

            if ( ( "function" === typeof cmd.onError ) && ( null !== cmd.onError ) ) {

                if ( "undefined" === typeof obj ) {
                    cmd.onError( this );
                }
                else {
                    cmd.onError( this, obj );
                }
            }
        }
    };

    /**
     * Signal a connection error.
     */
    this.signalConnError = function() {
        if ( ( "function" === typeof this.onConnError ) &&
             ( null !== this.onConnError ) ) {
            this.onConnError( this );
        }
    };

    /**
     * Signal a received VSCP response message.
     * If the message is handled by the application, the application will return
     * true, which means no further actions shall take place in this object.
     * Otherwise the message is handled by the standard onMessage handler here.
     *
     * @param {string} msg - VSCP server response message
     * @return {boolean} Message is handled (true) or not (false).
     */
    this.signalMessage = function( msg ) {
        var status = false;

        if ( ( "function" === typeof this.onMessage ) &&
             ( null !== this.onMessage ) ) {

            if ( true === this.onMessage( this, msg ) ) {
                status = true;
            }
        }

        return status;
    };

    /**
     * Signal a received VSCP event.
     *
     * @param {vscp.Event} vscpEvent - VSCP event
     */
    this.signalEvent = function( vscpEvent ) {
        var index = 0;

        /* Signal event to all event listeners */
        for( index = 0; index < this.onEvent.length; ++index ) {
            if ( ( "function" === typeof this.onEvent[ index ] ) &&
                 ( null !== this.onEvent[ index ] ) ) {
                this.onEvent[ index ]( this, vscpEvent );
            }
        }
    };

    /**
     * Signal a received variable.
     *
     * @param {object} variable                 - Variable object
     * @param {number} variable.id              - Consecutive number
     * @param {string} variable.name            - Variable name
     * @param {string} variable.type            - Variable type
     * @param {boolean} variable.persistency    - Variable is persistent (true) or not (false)
     * @param {string} variable.value           - Variable value
     */
    this.signalVariable = function( variable ) {
        if ( ( "function" === typeof this.onVariable ) &&
             ( null !== this.onVariable ) ) {
            this.onVariable( this, variable );
        }
    };

    /**
     * Signal a received table row.
     *
     * @param {object} row          - Table row object
     * @param {string} row.date     - Date and time
     * @param {string} row.value    - Value
     */
    this.signalTableRow = function( row ) {
        if ( ( "function" === typeof this.onTableRow ) &&
             ( null !== this.onTableRow ) ) {
            this.onTableRow( this, row );
        }
    };

    /**
     * Add a event listener.
     *
     * @param {function} eventListener - Event listener function
     */
    this.addEventListener = function( eventListener ) {
        if ( "function" === typeof eventListener ) {
            this.onEvent.push( eventListener );
        }
    };

    /**
     * Remove a event listener.
     *
     * @param {function} eventListener - Event listener function
     */
    this.removeEventListener = function( eventListener ) {
        var index = 0;

        for( index = 0; index < this.onEvent.length; ++index ) {
            if ( this.onEvent[ index ] === eventListener ) {
                this.onEvent.splice( index, 1 );
            }
        }

    };

    return this;
};

/**
 * This function is called by the websocket in case the connection is established.
 * It will initiate the authentication with the VSCP server.
 */
vscp.Connection.prototype.onWebSocketOpen = function() {

    console.info( vscp.utility.getTime() + " Websocket connection established." );
    this.state = this.states.CONNECTED;

    console.info( vscp.utility.getTime() + " Initiate authentication." );

    this._sendCommand({
        command: "CHALLENGE",
        data: "",
        onSuccess: null,
        onError: null
    });
};

/**
 * This function is called by the websocket in case that the connection is closed.
 */
vscp.Connection.prototype.onWebSocketClose = function() {

    console.info( vscp.utility.getTime() + " Websocket connection closed." );
    this.state = this.states.DISCONNECTED;
    this.signalConnError();
};

/**
 * This function is called for any websocket message (VSCP server response message).
 *
 * @param {string} msg - VSCP server response message
 */
vscp.Connection.prototype.onWebSocketMessage = function( msg ) {

    var msgItems = msg.data.split(";"); /* Data is separated by ; */
    var cmd = null;
    var eventItems = [];
    var evt = null;
    var offset = 0;
    var index = 0;

    console.debug( vscp.utility.getTime() + " Rsp: " + msg.data );

    /* Send message to application. If the application handled the message,
     * nothing more to. Otherwise the message will be handled now.
     */
    if ( false === this.signalMessage( msg ) ) {

        if ( "+" === msgItems[ 0 ] ) {

            if ( "AUTH0" === msgItems[ 1 ] ) {

                cmd = this.getPendingCommand( "CHALLENGE" );

                if ( null !== cmd ) {
                    console.info( vscp.utility.getTime() + " Security challenge received." );

                    this._sendCommand({
                        command: "AUTH",
                        data: this.userName + ";" + vscp.utility.getWebSocketAuthHash(
                            this.userName,
                            this.passwordHash,
                            msgItems[ 2 ]
                        ),
                        onSuccess: null,
                        onError: null
                    });
                }
            }
            else if ( "AUTH1" === msgItems[ 1 ] ) {

                cmd = this.getPendingCommand( "AUTH" );

                if ( null !== cmd ) {
                    console.info( vscp.utility.getTime() + " Authentication successful." );

                    if ( this.states.CONNECTED === this.state ) {
                        this.state = this.states.AUTHENTICATED;
                        this.signalSuccess( "FUNCTION_CONNECT" );
                    }
                }
            }
            else if ( "OPEN" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Receiving events started." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "CLOSE" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Receiving events stopped." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "CLRQUEUE" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " VSCP event queue cleared." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "EVENT" === msgItems[ 1 ] ) {
                //console.info( vscp.utility.getTime() + " VSCP event successful sent." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "SETFILTER" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Filter successful set." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "READVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable " + msgItems[ 2 ] + " (" + msgItems[ 4 ] + ") successful read." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ],    // Variable name
                        type: msgItems[ 3 ],    // Variable type
                        value: msgItems[ 4 ]    // Variable value
                    }
                );
            }
            else if ( "WRITEVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable successful written." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ],    // Variable name
                        type: msgItems[ 3 ],    // Variable type
                        value: msgItems[ 4 ]    // Variable value
                    }
                );
            }
            else if ( "CREATEVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable successful created." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "RESETVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable successful reset." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ],    // Variable name
                        type: msgItems[ 3 ],    // Variable type
                        value: msgItems[ 4 ]    // Variable value
                    }
                );
            }
            else if ( "REMOVEVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable successful removed." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ] // Variable name
                    }
                );
            }
            else if ( "LENGTHVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable length successful read." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ],                // Variable name
                        length: parseInt( msgItems[ 3 ] )   // Variable length
                    }
                );
            }
            else if ( "LASTCHANGEVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable last change successful read." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        name: msgItems[ 2 ],        // Variable name
                        lastChange: msgItems[ 3 ]   // Variable last changed
                    }
                );
            }
            else if ( "LISTVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variable successful listed." );
                this.signalSuccess( msgItems[ 1 ] );
                this.signalVariable({
                        id: parseInt( msgItems[ 2 ] ),                              // Consecutive number
                        name: msgItems[ 3 ],                                        // Variable name
                        type: msgItems[ 4 ],                                        // Variable type
                        persistency: ( "false" === msgItems[ 5 ] ) ? false : true,  // Variable persistency
                        value: msgItems[ 6 ]                                        // Variable value
                });
            }
            else if ( "SAVEVAR" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Variables successful saved." );
                this.signalSuccess( msgItems[ 1 ] );
            }
            else if ( "GT" === msgItems[ 1 ] ) {
                console.info( vscp.utility.getTime() + " Table successful read." );
                this.signalSuccess(
                    msgItems[ 1 ],
                    {
                        count: parseInt( msgItems[ 2 ] )    // Number of rows that will follow via TR
                    }
                );
            }
            else if ( "TR" === msgItems[ 1 ] ) {
                this.signalTableRow({
                    date: msgItems[ 2 ],    // Date and time
                    value: msgItems[ 3 ]    // Value
                });
            }
            else {
                console.debug( "Unknown message: " + msg.data );
                this.signalSuccess( msgItems[ 1 ] );
            }
        }
        else if ( "-" === msgItems[ 0 ] ) {

            if ( "AUTH0" === msgItems[ 1 ] ) {

                console.error( vscp.utility.getTime() + " Authentication initiation aborted." );

                cmd = this.getPendingCommand( "FUNCTION_CONNECT" );

                if ( null !== cmd ) {
                    this.signalConnError();
                    this.socket.close();
                }
                else {
                    console.error( vscp.utility.getTime() + " AUTH0 negative reply received, but no challenge is pending!?" );
                }
            }
            else if ( "AUTH1" === msgItems[ 1 ] ) {

                console.error( vscp.utility.getTime() + " Authentication failed." );

                cmd = this.getPendingCommand( "FUNCTION_CONNECT" );

                if ( null !== cmd ) {
                    this.signalConnError();
                    this.socket.close();
                }
                else {
                    console.error( vscp.utility.getTime() + " AUTH1 negative reply received, but no challenge is pending!?" );
                }
            }
            else if ( "OPEN" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Receiving events couldn't be started." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "CLOSE" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Receiving events couldn't be stopped." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "CLRQUEUE" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " VSCP event queue couldn't be cleared." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "EVENT" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Failed to send VSCP event." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "SETFILTER" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Filter couldn't bet set." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "READVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable couldn't be read." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "WRITEVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable couldn't be written." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "CREATEVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable couldn't be created." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "RESETVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable couldn't be reset." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "REMOVEVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable couldn't be removed." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "LENGTHVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable length couldn't be read." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "LASTCHANGEVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variable last change couldn't be read." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "LISTVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variables couldn't be listed." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "SAVEVAR" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Variables couldn't be saved." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else if ( "GT" === msgItems[ 1 ] ) {
                console.error( vscp.utility.getTime() + " Table couldn't be read." );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
            else {
                console.error( "Unknown message: " + msg.data );
                this.signalError(
                    msgItems[ 1 ],
                    {
                        id: parseInt( msgItems[ 2 ] ),  // Error code
                        str: msgItems[ 3 ]              // Error string
                    }
                );
            }
        }
        else if ( "E" === msgItems[ 0 ] ) {

            eventItems = msgItems[ 1 ].split( "," );

            evt = new vscp.Event();

            evt.vscpHead        = parseInt( eventItems[ 0 ] );
            evt.vscpClass       = parseInt( eventItems[ 1 ] );
            evt.vscpType        = parseInt( eventItems[ 2 ] );
            evt.vscpObId        = parseInt( eventItems[ 3 ] );
            evt.vscpTimeStamp   = parseInt( eventItems[ 4 ] );
            evt.vscpGuid        = eventItems[ 5 ];
            evt.vscpData        = [];

            if ( ( 512 <= evt.vscpClass ) && ( 1024 > evt.vscpClass ) ) {
                offset = 16;
            }

            for( index = 0; index < ( eventItems.length - 6 - offset ); ++index) {
                evt.vscpData[ index ] = parseInt( eventItems[ offset + 6 + index ] );
            }

            console.debug( vscp.utility.getTime() + " Evt: GUID = " + evt.vscpGuid + " CLASS = " + evt.vscpClass + " TYPE = " + evt.vscpType + " PRIORITY = " + evt.getPriority() + " DATA = " + evt.vscpData );

            this.signalEvent( evt );
        }
    }
};

/**
 * Connect to a VSCP server with the given URL.
 *
 * @param {object} options                  - Options
 * @param {string} options.url              - URL to the VSCP server, e.g. ws://
 * @param {string} options.userName         - User name used for authentication
 * @param {string} options.password         - Password used for authentication
 * @param {function} [options.onMessage]    - Function which is called on any received VSCP response message.
 * @param {function} [options.onSuccess]    - Function which is called on a successful connection establishment.
 * @param {function} [options.onError]      - Function which is called on a failed connection establishment or in case the connection is lost during the session.
 */
vscp.Connection.prototype.connect = function( options ) {

    var onSuccess = null;

    if ( this.states.DISCONNECTED !== this.state ) {
        console.error( vscp.utility.getTime() + " A connection already exists." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.url ) {
        console.error( vscp.utility.getTime() + " URL is missing." );
        return;
    }

    if ( "string" !== typeof options.userName ) {
        console.error( vscp.utility.getTime() + " User name is missing." );
        return;
    }

    this.userName = options.userName;

    if ( "string" !== typeof options.password ) {
        console.error( vscp.utility.getTime() + " Password is missing." );
        return;
    }

    this.passwordHash = options.password;

    if ( "function" !== typeof options.onMessage ) {
        this.onMessage = null;
    }
    else {
        this.onMessage = options.onMessage;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" !== typeof options.onError ) {
        this.onConnError = null;
    }
    else {
        this.onConnError = options.onError;
    }

    console.info( vscp.utility.getTime() + " Websocket connect to " + options.url + " (user name: " + this.userName + ", password hash: " + this.passwordHash + ")");

    this.socket = new WebSocket( options.url );

    if ( null === this.socket ) {
        console.error( vscp.utility.getTime() + " Couldn't open a websocket connection." );

        this.signalConnError();

        this.onConnError = null;
        this.onMessage = null;
    }
    else {

        this._sendCommand({
            command: "FUNCTION_CONNECT",
            data: "",
            simulate: true,
            onSuccess: onSuccess,
            onError: null
        });

        this.socket.onopen = this.onWebSocketOpen.bind( this );
        this.socket.onclose = this.onWebSocketClose.bind( this );
        this.socket.onmessage = this.onWebSocketMessage.bind( this );
    }
};

/**
 * Disconnect from a VSCP server.
 */
vscp.Connection.prototype.disconnect = function() {

    console.info( vscp.utility.getTime() + " Disconnect websocket connection.");

    if ( null !== this.socket ) {
        this.onConnError = null;
        this.onMessage = null;
        this.onEvent = [];
        this.socket.close();
        this.socket = null;
        this.state = this.states.DISCONNECTED;
        this.cmdQueue = [];
    }
};

/**
 * Start receiving events.
 *
 * @param {object} options                  - Options
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.start = function( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( this.states.AUTHENTICATED !== this.state ) {
        console.error( vscp.utility.getTime() + " Connection is not authenticated." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "OPEN",
        data: "",
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Stop receiving events.
 *
 * @param {object} options                  - Options
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.stop = function( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( this.states.AUTHENTICATED !== this.state ) {
        console.error( vscp.utility.getTime() + " Connection is not authenticated." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "CLOSE",
        data: "",
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Clear the VSCP event queue on the server side.
 *
 * @param {object} options                  - Options
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.clearQueue = function( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( this.states.AUTHENTICATED !== this.state ) {
        console.error( vscp.utility.getTime() + " Connection is not authenticated." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "CLRQUEUE",
        data: "",
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Send a VSCP event to the VSCP server.
 *
 * @param {object} options                  - Options
 * @param {vscp.Event} options.event        - VSCP event to send
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.sendEvent = function ( options ) {

    var cmdData     = "";
    var onSuccess   = null;
    var onError     = null;
    var index       = 0;

    if ( this.states.AUTHENTICATED !== this.state ) {
        console.error( vscp.utility.getTime() + " Connection is not authenticated." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "undefined" === typeof options.event ) {
        console.error( vscp.utility.getTime() + " VSCP event is missing. " );
        return;
    }

    if ( false === options.event instanceof vscp.Event ) {
        console.error( vscp.utility.getTime() + " Event is invalid. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    cmdData += options.event.vscpHead.toString() + ",";
    cmdData += options.event.vscpClass.toString() + ",";
    cmdData += options.event.vscpType.toString() + ",";
    cmdData += options.event.vscpObId.toString() + ",";
    cmdData += options.event.vscpTimeStamp.toString() + ",";
    cmdData += options.event.vscpGuid.toString();

    if ( options.event.vscpData instanceof Array ) {

        if ( 0 < options.event.vscpData.length ) {
            cmdData += ",";
        }

        for( index = 0; index < options.event.vscpData.length; ++index ) {
            cmdData += options.event.vscpData[ index ].toString();

            if ( ( options.event.vscpData.length - 1 ) > index ) {
                cmdData += ",";
            }
        }

    }
    else if ( "string" === typeof options.event.vscpData ) {

        if ( 0 < options.event.vscpData.length ) {
            cmdData += ",";
        }

        cmdData += options.event.vscpData;
    }
    else {

        console.error( vscp.utility.getTime() + " Invalid VSCP event data." );
        return;
    }

    this._sendEvent({
        data: cmdData,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Set a filter in the VSCP server for VSCP events.
 *
 * @param {object} options                      - Options
 * @param {number} options.filterPriority       - Priority filter
 * @param {number} options.filterClass          - Class filter
 * @param {number} options.filterType           - Type filter
 * @param {number[]|string} options.filterGuid  - GUID filter
 * @param {number} options.maskPriority         - Priority mask
 * @param {number} options.maskClass            - Class mask
 * @param {number} options.maskType             - Type mask
 * @param {number[]|string} options.maskGuid    - GUID mask
 * @param {function} [options.onSuccess]        - Function which is called on a successful operation
 * @param {function} [options.onError]          - Function which is called on a failed operation
 */
vscp.Connection.prototype.setFilter = function ( options ) {

    var onSuccess       = null;
    var onError         = null;
    var cmdData         = "";
    var index           = 0;
    var filterPriority  = 0;
    var filterClass     = 0;
    var filterType      = 0;
    var filterGuid      = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    var maskPriority    = 0;
    var maskClass       = 0xffff;
    var maskType        = 0xffff;
    var maskGuid        = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];

    if ( this.states.AUTHENTICATED !== this.state ) {
        console.error( vscp.utility.getTime() + " Connection is not authenticated." );
        return;
    }

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "number" === typeof options.filterPriority ) {
        filterPriority = options.filterPriority;
    }

    if ( "number" === typeof options.filterClass ) {
        filterClass = options.filterClass;
    }

    if ( "number" === typeof options.filterType ) {
        filterType = options.filterType;
    }

    if ( options.filterGuid instanceof Array) {
        if ( 16 !== options.filterGuid.length ) {
            console.error( vscp.utility.getTime() + " GUID filter length is invalid. " );
            return;
        }

        filterGuid = options.filterGuid;
    }
    else if ( "string" === typeof options.filterGuid ) {

        filterGuid = vscp.utility.strToGuid( options.filterGuid );

        if ( 16 !== filterGuid.length ) {
            console.error( vscp.utility.getTime() + " GUID filter is invalid. " );
            return;
        }
    }

    if ( "number" === typeof options.maskPriority ) {
        maskPriority = options.maskPriority;
    }

    if ( "number" === typeof options.maskClass ) {
        maskClass = options.maskClass;
    }

    if ( "number" === typeof options.maskType ) {
        maskType = options.maskType;
    }

    if ( options.maskGuid instanceof Array) {
        if ( 16 !== options.maskGuid.length ) {
            console.error( vscp.utility.getTime() + " GUID mask length is invalid. " );
            return;
        }

        maskGuid = options.maskGuid;
    }
    else if ( "string" === typeof options.maskGuid ) {

        maskGuid = vscp.utility.strToGuid( options.maskGuid );

        if ( 16 !== maskGuid.length ) {
            console.error( vscp.utility.getTime() + " GUID mask is invalid. " );
            return;
        }
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    cmdData += "0x" + filterPriority.toString( 16 ) + ",";
    cmdData += "0x" + filterClass.toString( 16 ) + ",";
    cmdData += "0x" + filterType.toString( 16 ) + ",";

    for( index = 0; index < 16; ++index) {

        cmdData += "0x" + ( filterGuid[ index ] & 0xff ).toString( 16 );

        if ( 15 > index ) {
            cmdData += ":";
        }
    }

    cmdData += ";";
    cmdData += "0x" + maskPriority.toString( 16 ) + ",";
    cmdData += "0x" + maskClass.toString( 16 ) + ",";
    cmdData += "0x" + maskType.toString( 16 ) + ",";

    for( index = 0; index < 16; ++index) {

        cmdData += "0x" + ( maskGuid[ index ] & 0xff ).toString( 16 );

        if ( 15 > index ) {
            cmdData += ":";
        }
    }

    this._sendCommand({
        command: "SETFILTER",
        data: cmdData,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Read a value from a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.readVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "READVAR",
        data: options.name,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Write a value to a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {string} options.value            - Variable value
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.writeVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "string" !== typeof options.value ) {
        console.error( vscp.utility.getTime() + " Variable value is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "WRITEVAR",
        data: options.name + ";" + options.value,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Create a a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {number} options.type             - Variable type
 * @param {string} options.value            - Variable value
 * @param {boolean} options.persistency     - Variable is persistent (true) or not (false)
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.createVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;
    var persistency = 1;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "number" !== typeof options.type ) {
        console.error( vscp.utility.getTime() + " Variable type is missing. " );
        return;
    }

    if ( "string" !== typeof options.value ) {
        console.error( vscp.utility.getTime() + " Variable value is missing. " );
        return;
    }

    if ( "boolean" === typeof options.persistency ) {
        if ( false === options.persistency ) {
            persistency = 0;
        }
        else {
            persistency = 1;
        }
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "CREATEVAR",
        data: options.name + ";" + options.type + ";" + persistency + ";" + options.value,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Reset a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.resetVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "RESETVAR",
        data: options.name,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Remove a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.removeVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "REMOVEVAR",
        data: options.name,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Get a VSCP server variable length.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.lengthVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "LENGTHVAR",
        data: options.name,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Get last change of a VSCP server variable.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Variable name
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.lastChangeVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Variable name is missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "LASTCHANGEVAR",
        data: options.name,
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * List all VSCP server variables.
 *
 * @param {object} options                  - Options
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.listVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "function" !== typeof options.onVariable ) {
        console.error( vscp.utility.getTime() + " onVariable is missing. " );
        return;
    }

    this.onVariable = options.onVariable;

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "LISTVAR",
        data: "",
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Save persistent variables.
 *
 * @param {object} options                  - Options
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.saveVar = function ( options ) {

    var onSuccess   = null;
    var onError     = null;

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    this._sendCommand({
        command: "SAVEVAR",
        data: "",
        onSuccess: onSuccess,
        onError: onError
    });
};

/**
 * Get data from a table.
 * If "begin" and "end" are omitted, the whole table is returned.
 *
 * @param {object} options                  - Options
 * @param {string} options.name             - Table name
 * @param {string} options.begin            - Date when to begin ( ISO form YY-MM-DD HH:MM:SS )
 * @param {string} options.end              - Date when to end ( ISO form YY-MM-DD HH:MM:SS )
 * @param {function} options.onTableRow     - Function which is called on every received table row
 * @param {function} [options.onSuccess]    - Function which is called on a successful operation
 * @param {function} [options.onError]      - Function which is called on a failed operation
 */
vscp.Connection.prototype.readTable = function ( options ) {

    var onSuccess   = null;
    var onError     = null;
    var rowBegin    = null;
    var rowEnd      = null;
    var data        = "";

    if ( "undefined" === typeof options ) {
        console.error( vscp.utility.getTime() + " Options are missing. " );
        return;
    }

    if ( "string" !== typeof options.name ) {
        console.error( vscp.utility.getTime() + " Table name is missing. " );
        return;
    }

    if ( "function" !== typeof options.onTableRow ) {
        console.error( vscp.utility.getTime() + " onTableRow function is missing. " );
        return;
    }

    this.onTableRow = options.onTableRow;

    if ( "string" === typeof options.begin ) {
        rowBegin = options.begin;
    }

    if ( "string" === typeof options.end ) {
        rowEnd = options.end;
    }

    if ( "function" === typeof options.onSuccess ) {
        onSuccess = options.onSuccess;
    }

    if ( "function" === typeof options.onError ) {
        onError = options.onError;
    }

    data = options.name;

    if ( ( null !== rowBegin ) &&
         ( null !== rowEnd ) ) {

        data += ";" + rowBegin + ";" + rowEnd;
    }

    this._sendCommand({
        command: "GT",
        data: data,
        onSuccess: onSuccess,
        onError: onError
    });
};
