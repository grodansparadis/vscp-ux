<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>DM STD Configuration</title>

    <!-- Don't cache the page -->
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="-1" />

    <script type="text/javascript" src="../js/md5.js"></script>
    <script type="text/javascript" src="../js/vscp.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
    <script type="text/javascript" src="../js/dmNG.js"></script>
    <script type="text/javascript">
        /*jshint bitwise: false */

        // VSCP websocket connection
        var vscpConn = null;
        
        // Standard decision matrix row
        var DMStdRow = function( options ) {
            
            this.oAddr = 0;
            this.flags = 0;
            this.classMask = 0;
            this.classFilter = 0;
            this.typeMask = 0;
            this.typeFilter = 0;
            this.action = 0;
            this.actionParameter = 0;
            this.dirty = 0;
                                    
            if ( "undefined" !== typeof options ) {
                if ( "number" === typeof options.oAddr ) {
                    this.oAddr = options.oAddr;
                }
                if ( "number" === typeof options.flags ) {
                    this.flags = options.flags;
                }
                if ( "number" === typeof options.classMask ) {
                    this.classMask = options.classMask;
                }
                if ( "number" === typeof options.classFilter ) {
                    this.classFilter = options.classFilter;
                }
                if ( "number" === typeof options.typeMask ) {
                    this.typeMask = options.typeMask;
                }
                if ( "number" === typeof options.typeFilter ) {
                    this.typeFilter = options.typeFilter;
                }
                if ( "number" === typeof options.action ) {
                    this.action = options.action;
                }
                if ( "number" === typeof options.actionParameter ) {
                    this.actionParameter = options.actionParameter;
                }
            }
            
            this.setOAddr = function( oAddr ) {
                this.oAddr = oAddr;
                this.dirty |= 0x01;
            };
            
            this.setFlags = function( flags ) {
                this.flags = flags;
                this.dirty |= 0x02;
            };
            
            this.setClassMask = function( classMask ) {
                this.classMask = classMask;
                this.dirty |= 0x04;
            };
            
            this.setClassFilter = function( classFilter ) {
                this.classFilter = classFilter;
                this.dirty |= 0x08;
            };
            
            this.setTypeMask = function( typeMask ) {
                this.typeMask = typeMask;
                this.dirty |= 0x10;
            };
            
            this.setTypeFilter = function( typeFilter ) {
                this.typeFilter = typeFilter;
                this.dirty |= 0x20;
            };
            
            this.setAction = function( action ) {
                this.action = action;
                this.dirty |= 0x40;
            };
            
            this.setActionParameter = function( actionParameter ) {
                this.actionParameter = actionParameter;
                this.dirty |= 0x80;
            };
        };
        
        // Standard decision matrix
        var dmStd = [];
        
        // User interface data
        var ui = {

            getNodeId: function() {
                return parseInt( $( "#nodeId" ).val() );
            },

            getPage: function() {
                return parseInt( $( "#page" ).val() );
            },

            getOffset: function() {
                return parseInt( $("#offset").val() );
            },

            getNumberOfRows: function() {
                return parseInt( $("#numberOfRows").val() );
            },
            
            enable: function() {
                $( "#ui :input" ).attr( "disabled", false );
            },
            
            disable: function() {
                $( "#ui :input" ).attr( "disabled", true );
            }
        };

        // Wait until the whole website is loaded, until connection to the VSCP server
        $( document ).ready( function() {

            // Create a VSCP websocket
            vscpConn = new vscp.Connection();

            // Connect to VSCP server
            vscpConn.connect({

                url: "ws://104.236.235.81:8080",

                userName: "admin",

                password: "d50c3180375c27927c22e42a379c3f67",

                onSuccess: function( conn ) {

                    // Set filter for CLASS1.Protocol
                    vscpConn.setFilter({
                        filterClass: 0x0000,
                        maskClass: 0xffff,
                        filterType: 0x0000,
                        maskType: 0x0000
                    });

                    // Start receiving VSCP events
                    vscpConn.start({
                        onSuccess: function( conn ) {
                            // Add a event listener
                            vscpConn.addEventListener( vscpEventCallback );
                            
                            // Enable the user interface
                            ui.enable();
                        },
                        onError: function( conn ) {
                            alert("Couldn't start receiving events.");
                        }
                    });
                },

                onError: function( conn ) {
                    alert("Connection lost. Please reload website.");
                }
            });

            update( "configuration" );
        });

        // Update the configuration, which is shown the user
        function update( id ) {
            var head        = "";
            var body        = "";
            var footer      = "";
            var rowIndex    = 0;
            
            // Head
            head += '<table border="1" cellspacing="1" cellpadding="10">';
            head += '    <thead>';
            head += '        <tr>';
            head += '            <th>Number</th>';
            head += '            <th>Origination address</th>';
            head += '            <th>Class mask</th>';
            head += '            <th>Class filter</th>';
            head += '            <th>Type mask</th>';
            head += '            <th>Type filter</th>';
            head += '            <th>Action</th>';
            head += '            <th>Action parameter</th>';
            head += '        </tr>';
            head += '    </thead>';
            head += '    <tbody>';
            
            //Body

            // Print the rows
            for(rowIndex = 0; rowIndex < dmStd.length; ++rowIndex) {
                body += '        <tr>';
                body += '            <td>' + (rowIndex + 1) + '</td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].oAddr + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setOAddr( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].classMask + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setClassMask( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].classFilter + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setClassFilter( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].typeMask + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setTypeMask( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].typeFilter + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setTypeFilter( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].action + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setAction( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '            <td>';
                body += '                <input type="number" value="' + dmStd[ rowIndex ].actionParameter + '" min="0" max="255" onchange="dmStd[ ' + rowIndex + ' ].setActionParameter( parseInt( this.value ) );" />';
                body += '            </td>';
                body += '        </tr>';
            }

            // Footer
            footer += '    </tbody>';
            footer += '</table>';

            // Update now at once
            $( "#" + id ).html( '<p>' + head + body + footer + '</p>' );
        }
        
        var operation = {
            
            states: {
                NO_OPERATION: 0,
                READ_CONFIGURATION: 1,
                WRITE_CONFIGURATION: 2
            },
            
            state: 0,
            
            read: {
                
                offset: 0,
                row: 0,
                rowOffset: 0,
                timerHandle: null                
            },
            
            write: {
            
                offset: 0,
                timerHandle: null
            },            
        };

        // This function is called for every received VSCP event
        function vscpEventCallback( conn, evt ) {

            var index   = 0;
            var data    = [];

            if ( "undefined" === typeof evt ) {
                return;
            }

            if ( false === ( evt instanceof vscp.Event ) ) {
                return;
            }

            // Only CLASS1.PROTOCOL events are interesting
            if ( vscp.constants.classes.VSCP_CLASS1_PROTOCOL !== evt.vscpClass ) {
                return;
            }

            // Especially the extended register read/write responses
            if ( vscp.constants.types.VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_RESPONSE !== evt.vscpType ) {
                return;
            }

            // Reading the decision matrix configuration?
            if ( operation.states.READ_CONFIGURATION === operation.state ) {

                // Clear timer, because node answer was received
                clearTimeout( operation.read.timerHandle );
                
                if ( 0 === operation.read.rowOffset ) {
                    dmStd.push( new DMStdRow() );
                }
                
                for( index = 0; index < ( evt.vscpData.length - 4 ); ++index ) {
                    
                    if ( 0 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].oAddr = evt.vscpData[ 4 + index ];
                    }
                    else if ( 1 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].flags = evt.vscpData[ 4 + index ];
                    }
                    else if ( 2 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].classMask = evt.vscpData[ 4 + index ];
                    }
                    else if ( 3 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].classFilter = evt.vscpData[ 4 + index ];
                    }
                    else if ( 4 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].typeMask = evt.vscpData[ 4 + index ];
                    }
                    else if ( 5 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].typeFilter = evt.vscpData[ 4 + index ];
                    }
                    else if ( 6 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].action = evt.vscpData[ 4 + index ];
                    }
                    else if ( 7 === operation.read.rowOffset ) {
                        dmStd[ operation.read.row ].actionParameter = evt.vscpData[ 4 + index ];
                    }
                    
                    ++operation.read.rowOffset;
                }
                
                if ( 8 <= operation.read.rowOffset) {
                
                    dmStd[ operation.read.row ].dirty = 0;
                    operation.read.rowOffset = 0;
                    
                    ++operation.read.row;
                }
                
                if ( ui.getNumberOfRows() <= operation.read.row ) {
                    operation.state = operation.states.NO_OPERATION;
                    
                    update( 'configuration' );
                    
                    // Enable user interface
                    ui.enable();
                }
            }
            // Writing decision matrix configuration?
            else if ( operation.states.WRITE_CONFIGURATION === operation.state ) {
            
                clearTimeout( operation.write.timerHandle );
            
                // Finished?
                if ( operation.write.config.length <= operation.write.index ) {
                
                    // Enable user interface
                    ui.enable();
                    
                    return;
                }
            
                data = [
                    ui.getNodeId(),                 // Node address
                    ( ui.getPage() >> 8 ) & 0xff,   // MSB of page where the register is located.
                    ( ui.getPage() >> 0 ) & 0xff,   // LSB of page where the register is located.
                    operation.write.offset          // Register to write (offset into page).
                ];
                
                index = 0;
                while( ( ( operation.write.index + index ) < operation.write.config.length ) && ( 4 > index ) ) {
                    data.push( operation.write.config[ operation.write.index + index ] );
                    ++index;
                }
                operation.write.index += index;
                operation.write.offset += index;

                vscpConn.sendEvent({
                    event: new vscp.Event({
                        vscpClass:      vscp.constants.classes.VSCP_CLASS1_PROTOCOL,
                        vscpType:       vscp.constants.types.VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_WRITE,
                        vscpPriority:   vscp.constants.priorities.PRIORITY_3_NORMAL,
                        vscpData:       data
                    })
                });
            }
        }

        // Read configuration from node
        function readConfigFromNode() {

            var size = ui.getNumberOfRows() * 8;
        
            if ( 0 === size ) {
                return;
            }
            else if ( 256 === size ) {
                size = 0;
            }
        
            operation.read.offset = ui.getOffset();
            operation.read.rowOffset = 0;

            var data = [
                ui.getNodeId(),                 // Node address
                ( ui.getPage() >> 8 ) & 0xff,   // MSB of page where the register is located.
                ( ui.getPage() >> 0 ) & 0xff,   // LSB of page where the register is located.
                operation.read.offset,          // Register to read (offset into page).
                size                            // Number of registers to read.
            ];

            vscpConn.sendEvent({
                event: new vscp.Event({
                    vscpClass:      vscp.constants.classes.VSCP_CLASS1_PROTOCOL,
                    vscpType:       vscp.constants.types.VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_READ,
                    vscpPriority:   vscp.constants.priorities.PRIORITY_3_NORMAL,
                    vscpData:       data
                }),

                onSuccess: function( conn ) {

                    operation.state = operation.states.READ_CONFIGURATION;

                    // Disable the user interface
                    ui.disable();

                    operation.read.timerHandle = setTimeout(
                        function() {
                            console.log( "No response from node." );
                            alert( "No response from node." );

                            operation.state = operation.states.NO_OPERATION;

                            // Enable the user interface
                            ui.enable();
                        },
                        5000
                    );

                    // Clear decision matrix
                    dmStd = [];
                },

                onError: function( conn ) {
                    // Enable the user interface
                    ui.enable();

                    alert( "Error ocurred." );
                }
            });
        }

        // Write configuration to node
        function writeConfigToNode() {
        
            var index = 0;

            operation.write.config = dmNGInst.getConfig();
            operation.write.index  = 0;
            operation.write.offset = ui.getOffset();

            var data = [
                ui.getNodeId(),                 // Node address
                ( ui.getPage() >> 8 ) & 0xff,   // MSB of page where the register is located.
                ( ui.getPage() >> 0 ) & 0xff,   // LSB of page where the register is located.
                operation.write.offset          // Register to write (offset into page).
            ];
            
            index = 0;
            while( ( index < operation.write.config.length ) && ( 4 > ( index - operation.write.index ) ) ) {
                data.push( operation.write.config[ index ] );
                ++index;
            }
            operation.write.index += index;

            vscpConn.sendEvent({
                event: new vscp.Event({
                    vscpClass:      vscp.constants.classes.VSCP_CLASS1_PROTOCOL,
                    vscpType:       vscp.constants.types.VSCP_TYPE_PROTOCOL_EXTENDED_PAGE_WRITE,
                    vscpPriority:   vscp.constants.priorities.PRIORITY_3_NORMAL,
                    vscpData:       data
                }),

                onSuccess: function( conn ) {

                    operation.state = operation.states.WRITE_CONFIGURATION;
                    
                    operation.write.offset += index;

                    // Disable the user interface
                    ui.disable();

                    operation.write.timerHandle = setTimeout(
                        function() {
                            console.log( "No response from node." );
                            alert( "No response from node." );

                            operation.state = operation.states.NO_OPERATION;

                            // Enable the user interface
                            ui.enable();
                        },
                        5000
                    );
                },

                onError: function( conn ) {
                    // Enable the user interface
                    ui.enable();

                    alert( "Error ocurred." );
                }
            });
        }

    </script>
</head>
<body>
    <h1>Decision Matrix (standard) Configuration</h1>
    <div id="ui">
        <table style="border: 0px">
            <tr>
                <td>Node id:</td>
                <td><input id="nodeId" type="number" value="1" min="0" max="255" disabled /></td>
            </tr>
            <tr>
                <td>Page:</td>
                <td><input id="page" type="number" value="0" min="0" max="65535" disabled /></td>
            </tr>
            <tr>
                <td>Offset:</td>
                <td><input id="offset" type="number" value="0" min="0" max="255" disabled /></td>
            </tr>
            <tr>
                <td>Number of rows:</td>
                <td><input id="numberOfRows" type="number" value="10" min="1" max="32" disabled /></td>
            </tr>
        </table>
        <input type="submit" value="Read configuration from node" onclick="readConfigFromNode()" disabled /><br />
        <input type="submit" value="Write configuration to node" onclick="writeConfigToNode()" disabled /><br />
    </div>
    <div id="configuration">
    </div>
</body>
</html>
